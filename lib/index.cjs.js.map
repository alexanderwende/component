{"version":3,"file":"index.cjs.js","sources":["../src/utils/string-utils.ts","../src/decorators/attribute-converter.ts","../src/decorators/property-declaration.ts","../src/custom-element.ts","../src/decorators/custom-element.ts","../src/decorators/listener.ts","../src/decorators/get-property-descriptor.ts","../src/decorators/property.ts"],"sourcesContent":["const FIRST = /^[^]/;\nconst SPACES = /\\s+([\\S])/g;\nconst CAMELS = /[a-z]([A-Z])/g;\nconst KEBABS = /-([a-z])/g;\n\nexport function capitalize (string: string): string {\n\n    return string ? string.replace(FIRST, string[0].toUpperCase()) : string;\n}\n\nexport function uncapitalize (string: string): string {\n\n    return string ? string.replace(FIRST, string[0].toLowerCase()) : string;\n}\n\nexport function camelCase (string: string): string {\n\n    let matches;\n\n    if (string) {\n\n        string = string.trim();\n\n        while ((matches = SPACES.exec(string))) {\n\n            string = string.replace(matches[0], matches[1].toUpperCase());\n\n            SPACES.lastIndex = 0;\n        }\n\n        while ((matches = KEBABS.exec(string))) {\n\n            string = string.replace(matches[0], matches[1].toUpperCase());\n\n            KEBABS.lastIndex = 0;\n        }\n    }\n\n    return uncapitalize(string);\n}\n\nexport function kebabCase (string: string): string {\n\n    let matches;\n\n    if (string) {\n\n        string = string.trim();\n\n        while ((matches = SPACES.exec(string))) {\n\n            string = string.replace(matches[0], '-' + matches[1]);\n\n            SPACES.lastIndex = 0;\n        }\n\n        while ((matches = CAMELS.exec(string))) {\n\n            string = string.replace(matches[0], matches[0][0] + '-' + matches[1]);\n\n            CAMELS.lastIndex = 0;\n        }\n    }\n\n    return string ? string.toLowerCase() : string;\n}\n","/**\n * A function that will map an attribute value to a property value\n */\nexport type AttributeMapper<T = any> = (value: string | null) => T | null;\n\n/**\n * A function that will map a property value to an attribute value\n */\nexport type PropertyMapper<T = any> = (value: T | null) => string | null | undefined;\n\n/**\n * An object that holds an {@link AttributeMapper} and a {@link PropertyMapper}\n *\n * @remarks\n * For the most common types, a converter exists which can be referenced in the {@link PropertyDeclaration}.\n *\n * ```typescript\n * import { CustomElement, property, AttributeConverterBoolean } from 'custom-element';\n *\n * export class MyElement extends CustomElement {\n *\n *      @property({\n *          converter: AttributeConverterBoolean\n *      })\n *      myProperty = true;\n * }\n * ```\n */\nexport interface AttributeConverter<T = any> {\n    toAttribute: PropertyMapper<T>;\n    fromAttribute: AttributeMapper<T>;\n}\n\n/**\n * The default attribute converter\n *\n * @remarks\n * This converter is used as the default converter for decorated properties unless a different one\n * is specified. The converter tries to infer the property type when converting to attributes and\n * uses `JSON.parse()` when converting strings from attributes. If `JSON.parse()` throws an error,\n * the converter will use the attribute value as a string.\n */\nexport const AttributeConverterDefault: AttributeConverter = {\n    fromAttribute: (value: string | null) => {\n        // `JSON.parse()` will throw an error for empty strings - we consider it null\n        if (value === null || value === '') {\n            return null;\n        }\n        else\n            try {\n                // `JSON.parse()` will successfully parse `boolean`, `number` and `JSON.stringify`'d values\n                return JSON.parse(value);\n            }\n            catch (error) {\n                // if it throws, it means we're probably dealing with a regular string\n                return value;\n            }\n    },\n    toAttribute: (value: any) => {\n        switch (typeof value) {\n            case 'boolean':\n                return value ? '' : null;\n            case 'object':\n                return (value == null) ? value : JSON.stringify(value);\n            case 'undefined':\n                return value;\n            case 'string':\n                return value;\n            default: // number, bigint, symbol, function\n                return value.toString();\n        }\n    }\n};\n\nexport const AttributeConverterBoolean: AttributeConverter<boolean> = {\n    fromAttribute: (value: string | null) => (value !== null),\n    toAttribute: (value: boolean | null) => value ? '' : null\n}\n\nexport const AttributeConverterString: AttributeConverter<string> = {\n    fromAttribute: (value: string | null) => (value === null) ? null : value,\n    // pass through null or undefined\n    toAttribute: (value: string | null) => value\n}\n\nexport const AttributeConverterNumber: AttributeConverter<number> = {\n    fromAttribute: (value: string | null) => (value === null) ? null : Number(value),\n    // pass through null or undefined using `value == null`\n    toAttribute: (value: number | null) => (value == null) ? value : value.toString()\n}\n\nexport const AttributeConverterObject: AttributeConverter<object> = {\n    // `JSON.parse()` will throw an error for empty strings - we consider it null\n    fromAttribute: (value: string | null) => (value === null || value === '') ? null : JSON.parse(value),\n    // pass through null or undefined using `value == null`\n    toAttribute: (value: object | null) => (value == null) ? value : JSON.stringify(value)\n}\n\nexport const AttributeConverterArray: AttributeConverter<any[]> = {\n    // `JSON.parse()` will throw an error for empty strings - we consider it null\n    fromAttribute: (value: string | null) => (value === null || value === '') ? null : JSON.parse(value),\n    // pass through null or undefined using `value == null`\n    toAttribute: (value: any[] | null) => (value == null) ? value : JSON.stringify(value)\n};\n\nexport const AttributeConverterDate: AttributeConverter<Date> = {\n    // `new Date()` will return an `Invalid Date` for empty strings - we consider it null\n    fromAttribute: (value: string | null) => (value === null || value === '') ? null : new Date(value),\n    // pass through null or undefined using `value == null`\n    toAttribute: (value: Date | null) => (value == null) ? value : value.toString()\n}\n","import { CustomElement } from '../custom-element';\nimport { kebabCase } from '../utils/string-utils';\nimport { AttributeConverter, AttributeConverterDefault } from './attribute-converter';\n\n/**\n * A function that will reflect an attribute value to a property\n */\nexport type AttributeReflector<Type extends CustomElement = CustomElement> = (this: Type, attributeName: string, oldValue: string | null, newValue: string | null) => void;\n\n/**\n * A function that will reflect a property value to an attribute\n */\nexport type PropertyReflector<Type extends CustomElement = CustomElement> = (this: Type, propertyKey: PropertyKey, oldValue: any, newValue: any) => void;\n\n/**\n * A function that will dispatch a custom event for a property change\n */\nexport type PropertyNotifier<Type extends CustomElement = CustomElement> = (this: Type, propertyKey: PropertyKey, oldValue: any, newValue: any) => void;\n\n/**\n * A function that will return `true` if the `oldValue` and the `newValue` of a property are different, `false` otherwise\n */\nexport type PropertyChangeDetector = (oldValue: any, newValue: any) => boolean;\n\n/**\n * A type guard for {@link AttributeReflector}\n *\n * @param reflector A reflector to test\n */\nexport function isAttributeReflector (reflector: any): reflector is AttributeReflector {\n\n    return typeof reflector === 'function';\n}\n\n/**\n * A type guard for {@link PropertyReflector}\n *\n * @param reflector A reflector to test\n */\nexport function isPropertyReflector (reflector: any): reflector is PropertyReflector {\n\n    return typeof reflector === 'function';\n}\n\n/**\n * A type guard for {@link PropertyNotifier}\n *\n * @param notifier A notifier to test\n */\nexport function isPropertyNotifier (notifier: any): notifier is PropertyNotifier {\n\n    return typeof notifier === 'function';\n}\n\n/**\n * A type guard for {@link PropertyChangeDetector}\n *\n * @param detector A detector to test\n */\nexport function isPropertyChangeDetector (detector: any): detector is PropertyChangeDetector {\n\n    return typeof detector === 'function';\n}\n\n/**\n * A type guard for {@link PropertyKey}\n *\n * @param key A property key to test\n */\nexport function isPropertyKey (key: any): key is PropertyKey {\n\n    return typeof key === 'string' || typeof key === 'number' || typeof key === 'symbol';\n}\n\n/**\n * Encodes a string for use as html attribute removing invalid attribute characters\n *\n * @param value A string to encode for use as html attribute\n * @returns     An encoded string usable as html attribute\n */\nexport function encodeAttribute (value: string): string {\n\n    return kebabCase(value.replace(/\\W+/g, '-').replace(/\\-$/, ''));\n}\n\n/**\n * A helper function to create an attribute name from a property key\n *\n * @remarks\n * Numeric property indexes or symbols can contain invalid characters for attribute names. This method\n * sanitizes those characters and replaces sequences of invalid characters with a dash.\n * Attribute names are not allowed to start with numbers either and are prefixed with 'attr-'.\n *\n * N.B.: When using custom symbols as property keys, use unique descriptions for the symbols to avoid\n * clashing attribute names.\n *\n * ```typescript\n * const a = Symbol();\n * const b = Symbol();\n *\n * a !== b; // true\n *\n * createAttributeName(a) !== createAttributeName(b); // false --> 'attr-symbol' === 'attr-symbol'\n *\n * const c = Symbol('c');\n * const d = Symbol('d');\n *\n * c !== d; // true\n *\n * createAttributeName(c) !== createAttributeName(d); // true --> 'attr-symbol-c' === 'attr-symbol-d'\n * ```\n *\n * @param propertyKey   A property key to convert to an attribute name\n * @returns             The generated attribute name\n */\nexport function createAttributeName (propertyKey: PropertyKey): string {\n\n    if (typeof propertyKey === 'string') {\n\n        return kebabCase(propertyKey);\n\n    } else {\n\n        // TODO: this could create multiple identical attribute names, if symbols don't have unique description\n        return `attr-${ encodeAttribute(String(propertyKey)) }`;\n    }\n}\n\n/**\n * A helper function to create an event name from a property key\n *\n * @remarks\n * Event names don't have the same restrictions as attribute names when it comes to invalid\n * characters. However, for consistencies sake, we apply the same rules for event names as\n * for attribute names.\n *\n * @param propertyKey   A property key to convert to an attribute name\n * @param prefix        An optional prefix, e.g.: 'on'\n * @param suffix        An optional suffix, e.g.: 'changed'\n * @returns             The generated event name\n */\nexport function createEventName (propertyKey: PropertyKey, prefix?: string, suffix?: string): string {\n\n    let propertyString = '';\n\n    if (typeof propertyKey === 'string') {\n\n        propertyString = kebabCase(propertyKey);\n\n    } else {\n\n        // TODO: this could create multiple identical event names, if symbols don't have unique description\n        propertyString = encodeAttribute(String(propertyKey));\n    }\n\n    return `${ prefix ? `${ kebabCase(prefix) }-` : '' }${ propertyString }${ suffix ? `-${ kebabCase(suffix) }` : '' }`;\n}\n\n/**\n * A {@link CustomElement} property declaration\n */\nexport interface PropertyDeclaration<Type extends CustomElement = CustomElement> {\n    /**\n     * Does property have an associated attribute?\n     *\n     * @remarks\n     * Possible values:\n     * * `false`: No attribute will be associated with this property\n     * * `true`: The attribute name will be inferred by camel-casing the property name\n     * * `string`: Use the provided string as the associated attribute name\n     *\n     * Default value: `true`\n     */\n    attribute: boolean | string;\n\n    /**\n     * Customize the conversion of values between property and associated attribute\n     *\n     * @remarks\n     * Converters are only used when {@link reflectProperty} and/or {@link reflectAttribute} are set to true.\n     * If custom reflectors are used, they have to take care or converting the property/attribute values.\n     *\n     * Default value: `ATTRIBUTE_CONVERTERS.default`\n     */\n    converter: AttributeConverter;\n\n    /**\n     * Should the associated attribute's value be automatically reflected to the property?\n     *\n     * @remarks\n     * Possible values:\n     * * `false`: The attribute value will not be reflected to the property automatically\n     * * `true`: Any attribute change will be reflected automatically to the property using the default attribute reflector\n     * * `PropertyKey`: A method on the custom element with that property key will be invoked to handle the attribute reflection\n     * * `Function`: The provided function will be invoked with its `this` context bound to the custom element instance\n     *\n     * Default value: `true`\n     */\n    reflectAttribute: boolean | keyof Type | AttributeReflector<Type>;\n\n    /**\n     * Should the property value be automatically reflected to the associated attribute?\n     *\n     * @remarks\n     * Possible values:\n     * * `false`: The property value will not be reflected to the associated attribute automatically\n     * * `true`: Any property change will be reflected automatically to the associated attribute using the default property reflector\n     * * `PropertyKey`: A method on the custom element with that property key will be invoked to handle the property reflection\n     * * `Function`: The provided function will be invoked with its `this` context bound to the custom element instance\n     *\n     * Default value: `true`\n     */\n    reflectProperty: boolean | keyof Type | PropertyReflector<Type>;\n\n    /**\n     * Should a property value change raise a custom event?\n     *\n     * @remarks\n     * Possible values:\n     * * `false`: Don't create a custom event for this property\n     * * `true`: Create custom events for this property automatically\n     * * `PropertyKey`: Use the method with this property key on the custom element to create custom events\n     * * `Function`: Use the the provided function to create custom events (`this` context will be the custom element instance)\n     *\n     * Default value: `true`\n     */\n    notify: boolean | keyof Type | PropertyNotifier<Type>;\n\n    /**\n     * Configure how changes of this property should be monitored\n     *\n     * @remarks\n     * By default a decorated property will be observed for changes (through a custom setter for the property).\n     * Any `set`-operation of this property will therefore request an update of the custom element and initiate\n     * a render as well as reflection and notification.\n     *\n     * Possible values:\n     * * `false`: Don't observe changes of this property (this will bypass render, reflection and notification)\n     * * `true`: Observe changes of this property using the {@link DEFAULT_PROPERTY_CHANGE_DETECTOR}\n     * * `Function`: Use the provided method to check if property value has changed\n     *\n     * Default value: `true` (uses {@link DEFAULT_PROPERTY_CHANGE_DETECTOR} internally)\n     */\n    observe: boolean | PropertyChangeDetector;\n}\n\n/**\n * The default property change detector\n *\n * @param oldValue  The old property value\n * @param newValue  The new property value\n * @returns         A boolean indicating if the property value changed\n */\nexport const DEFAULT_PROPERTY_CHANGE_DETECTOR: PropertyChangeDetector = (oldValue: any, newValue: any) => {\n    // in case `oldValue` and `newValue` are `NaN`, `(NaN !== NaN)` returns `true`,\n    // but `(NaN === NaN || NaN === NaN)` returns `false`\n    return oldValue !== newValue && (oldValue === oldValue || newValue === newValue);\n};\n\n/**\n * The default {@link CustomElement} property declaration\n */\nexport const DEFAULT_PROPERTY_DECLARATION: PropertyDeclaration = {\n    attribute: true,\n    converter: AttributeConverterDefault,\n    reflectAttribute: true,\n    reflectProperty: true,\n    notify: true,\n    observe: DEFAULT_PROPERTY_CHANGE_DETECTOR,\n};\n","import { render, TemplateResult } from 'lit-html';\nimport { ListenerDeclaration } from './decorators/listener';\nimport { AttributeReflector, createEventName, isAttributeReflector, isPropertyChangeDetector, isPropertyKey, isPropertyNotifier, isPropertyReflector, PropertyDeclaration, PropertyNotifier, PropertyReflector } from \"./decorators/property-declaration\";\n\nconst ATTRIBUTE_REFLECTOR_ERROR = (attributeReflector: PropertyKey | Function) => new Error(`Error executing attribute reflector ${ String(attributeReflector) }.`);\nconst PROPERTY_REFLECTOR_ERROR = (propertyReflector: PropertyKey | Function) => new Error(`Error executing property reflector ${ String(propertyReflector) }.`);\nconst PROPERTY_NOTIFIER_ERROR = (propertyNotifier: PropertyKey | Function) => new Error(`Error executing property notifier ${ String(propertyNotifier) }.`);\nconst CHANGE_DETECTOR_ERROR = (changeDetector: PropertyKey | Function) => new Error(`Error executing property change detector ${ String(changeDetector) }.`);\n\n/**\n * Extends the static {@link ListenerDeclaration} to include the bound listener\n * for a custom element instance.\n */\ninterface InstanceListenerDeclaration extends ListenerDeclaration {\n\n    /**\n     * The bound listener will be stored here, so it can be removed it later\n     */\n    listener: EventListener;\n\n    /**\n     * The event target will always be resolved to an actual {@link EventTarget}\n     */\n    target: EventTarget;\n}\n\n/**\n * The custom element base class\n */\nexport abstract class CustomElement extends HTMLElement {\n\n    /**\n     * The custom element's selector\n     *\n     * @remarks\n     * Will be overridden by the {@link customElement} decorator's selector option, if provided.\n     * Otherwise the decorator will use this property to define the custom element.\n     */\n    static selector: string;\n\n    /**\n     * Use Shadow DOM\n     *\n     * @remarks\n     * Will be set by the {@link customElement} decorator's shadow option (defaults to `true`).\n     */\n    static shadow: boolean;\n\n    /**\n     * A map of attribute names and their respective property keys\n     *\n     * @internal\n     * @private\n     */\n    static attributes: Map<string, PropertyKey> = new Map();\n\n    /**\n     * A map of property keys and their respective property declarations\n     *\n     * @internal\n     * @private\n     */\n    static properties: Map<PropertyKey, PropertyDeclaration> = new Map();\n\n    /**\n     * A map of property keys and their respective listener declarations\n     *\n     * @internal\n     * @private\n     */\n    static listeners: Map<PropertyKey, ListenerDeclaration> = new Map();\n\n    /**\n     * Override to specify attributes which should be observed, but don't have an associated property\n     *\n     * @remark\n     * For properties which are decorated with the {@link property} decorator, an observed attribute\n     * is automatically created and does not need to be specified here. Fot attributes that don't\n     * have an associated property, return the attribute names in this getter. Changes to these\n     * attributes can be handled in the {@link attributeChangedCallback} method.\n     *\n     * When extending custom elements, make sure to return the super class's observedAttributes\n     * if you override this getter (except if you don't want to inherit observed attributes):\n     *\n     * ```typescript\n     * @customElement({\n     *      selector: 'my-element'\n     * })\n     * class MyElement extends MyBaseElement {\n     *\n     *      static get observedAttributes (): string[] {\n     *\n     *          return [...super.observedAttributes, 'my-additional-attribute'];\n     *      }\n     * }\n     * ```\n     */\n    static get observedAttributes (): string[] {\n\n        return [];\n    }\n\n    protected _renderRoot: Element | DocumentFragment;\n\n    protected _updateRequest: Promise<boolean> = Promise.resolve(true);\n\n    protected _changedProperties: Map<PropertyKey, any> = new Map();\n\n    protected _reflectingProperties: Map<PropertyKey, any> = new Map();\n\n    protected _notifyingProperties: Map<PropertyKey, any> = new Map();\n\n    protected _listenerDeclarations: InstanceListenerDeclaration[] = [];\n\n    protected _isConnected = false;\n\n    protected _hasUpdated = false;\n\n    protected _hasRequestedUpdate = false;\n\n    protected _isReflecting = false;\n\n    /**\n     * Returns `true` if the custom element's {@link connectedCallback} was executed.\n     */\n    get isConnected (): boolean {\n\n        return this._isConnected;\n    }\n\n    constructor () {\n\n        super();\n\n        this._renderRoot = this.createRenderRoot();\n    }\n\n    /**\n     * Invoked each time the custom element is moved to a new document\n     *\n     * @remarks\n     * https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements#Using_the_lifecycle_callbacks\n     */\n    adoptedCallback () {\n\n        this._notifyLifecycle('adopted');\n    }\n\n    /**\n     * Invoked each time the custom element is appended into a document-connected element\n     *\n     * @remarks\n     * https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements#Using_the_lifecycle_callbacks\n     */\n    connectedCallback () {\n\n        this._isConnected = true;\n\n        this._listen();\n\n        this.requestUpdate();\n\n        this._notifyLifecycle('connected');\n    }\n\n    /**\n     * Invoked each time the custom element is disconnected from the document's DOM\n     *\n     * @remarks\n     * https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements#Using_the_lifecycle_callbacks\n     */\n    disconnectedCallback () {\n\n        this._isConnected = false;\n\n        this._unlisten();\n\n        this._notifyLifecycle('disconnected');\n    }\n\n    /**\n     * Invoked each time one of the custom element's attributes is added, removed, or changed\n     *\n     * @remarks\n     * Which attributes to notice change for is specified in {@link observedAttributes}.\n     * https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements#Using_the_lifecycle_callbacks\n     *\n     * For decorated properties with an associated attribute, this is handled automatically.\n     *\n     * This method can be overridden to customize the handling of attribute changes. When overriding\n     * this method, a super-call should be included, to ensure attribute changes for decorated properties\n     * are processed correctly.\n     *\n     * ```typescript\n     * @customElement({\n     *      selector: 'my-element'\n     * })\n     * class MyElement extends CustomElement {\n     *\n     *      attributeChangedCallback (attribute: string, oldValue: any, newValue: any) {\n     *\n     *          super.attributeChangedCallback(attribute, oldValue, newValue);\n     *\n     *          // do custom handling...\n     *      }\n     * }\n     * ```\n     *\n     * @param attribute The name of the changed attribute\n     * @param oldValue  The old value of the attribute\n     * @param newValue  The new value of the attribute\n     */\n    attributeChangedCallback (attribute: string, oldValue: string | null, newValue: string | null) {\n\n        if (this._isReflecting) return;\n\n        if (oldValue !== newValue) this.reflectAttribute(attribute, oldValue, newValue);\n    }\n\n    /**\n     * Invoked each time the custom element updates\n     *\n     * @param changedProperties A map of properties that changed in the update, containg the property key and the old value\n     * @param firstUpdate       A boolean indicating if this was the first update\n     */\n    updateCallback (changedProperties: Map<PropertyKey, any>, firstUpdate: boolean) {\n\n        this._notifyLifecycle('update', { firstUpdate });\n    }\n\n    /**\n     * Creates the custom element's render root\n     *\n     * @remarks\n     * The render root is where the {@link render} method will attach its DOM output.\n     * When using the custom element with shadow mode, it will be a shadow root,\n     * otherwise it will be the custom element itself.\n     *\n     * TODO: Can slots be used without shadow DOM?\n     */\n    protected createRenderRoot (): Element | DocumentFragment {\n\n        return (this.constructor as typeof CustomElement).shadow ?\n            this.attachShadow({ mode: 'open' }) :\n            this;\n    }\n\n    /**\n     * Returns the template of the custom element\n     *\n     * @remarks\n     * Override this method to provide a template for your custom element. The method must\n     * return a {@link lit-html#TemplateResult} which is created using lit-html's\n     * {@link lit-html#html | `html`} or {@link lit-html#svg | `svg`} template methods.\n     *\n     * Return nothing if your component does not need to render a template.\n     *\n     * ```typescript\n     * import { html } from 'lit-html';\n     *\n     * @customElement({\n     *      selector: 'my-element'\n     * })\n     * class MyElement extends CustomElement {\n     *\n     *       myProperty = 'Hello';\n     *\n     *      template () {\n     *\n     *          html`<h1>${this.myProperty} World!</h1>`;\n     *      }\n     * }\n     * ```\n     */\n    protected template (): TemplateResult | void { }\n\n    /**\n     * Renders the custom element's template to its {@link _renderRoot}\n     *\n     * @remarks\n     * Uses lit-html's {@link lit-html#render} method to render a {@link lit-html#TemplateResult}.\n     */\n    protected render () {\n\n        const template = this.template();\n\n        if (template) render(template, this._renderRoot);\n    }\n\n    /**\n     * Watch property changes occurring in the executor and raise custom events\n     *\n     * @remarks\n     * Property changes should trigger custom events when they are caused by internal state changes,\n     * but not if they are caused by a consumer of the custom element API directly, e.g.:\n     *\n     * ```typescript\n     * document.querySelector('my-custom-element').customProperty = true;\n     * ```.\n     *\n     * This means, we cannot automate this process through property setters, as we can't be sure who\n     * invoked the setter - internal calls or external calls.\n     *\n     * One option is to manually raise the event, which can become tedious and forces us to use string-\n     * based event names or property names, which are difficult to refactor, e.g.:\n     *\n     * ```typescript\n     * this.customProperty = true;\n     * // if we refactor the property name, we can easily miss the notify call\n     * this.notify('customProperty');\n     * ```\n     *\n     * A more convenient way is to execute the internal changes in a wrapper which can detect the changed\n     * properties and will automatically raise the required events. This eliminates the need to manually\n     * raise events and refactoring does no longer affect the process.\n     *\n     * ```typescript\n     * this.watch(() => {\n     *\n     *      this.customProperty = true;\n     *      // we can add more property modifications to notify in here\n     * });\n     * ```\n     *\n     * @param executor A function that performs the changes which should be notified\n     */\n    protected watch (executor: () => void) {\n\n        // back up current changed properties\n        const previousChanges = new Map(this._changedProperties);\n\n        // execute the changes\n        executor();\n\n        // add all new or updated changed properties to the notifying properties\n        for (const [propertyKey, oldValue] of this._changedProperties) {\n\n            if (!previousChanges.has(propertyKey) || this.hasChanged(propertyKey, previousChanges.get(propertyKey), oldValue)) {\n\n                this._notifyingProperties.set(propertyKey, oldValue);\n            }\n        }\n    }\n\n    /**\n     * Request an update of the custom element\n     *\n     * @remarks\n     * This method is called automatically when the value of a decorated property or its associated\n     * attribute changes. If you need the custom element to update based on a state change that is\n     * not covered by a decorated property, call this method without any arguments.\n     *\n     * @param propertyKey   The name of the changed property that requests the update\n     * @param oldValue      The old property value\n     * @param newValue      the new property value\n     * @returns             A Promise which is resolved when the update is completed\n     */\n    protected requestUpdate (propertyKey?: PropertyKey, oldValue?: any, newValue?: any): Promise<boolean> {\n\n        if (propertyKey) {\n\n            if (!this.hasChanged(propertyKey, oldValue, newValue)) return this._updateRequest;\n\n            // store changed property for batch processing\n            this._changedProperties.set(propertyKey, oldValue);\n\n            // if we are in reflecting state, an attribute is reflecting to this property and we\n            // can skip reflecting the property back to the attribute\n            // property changes need to be tracked however and {@link render} must be called after\n            // the attribute change is reflected to this property\n            // TODO: Maybe don't put it here if not marked as reflected\n            if (!this._isReflecting) this._reflectingProperties.set(propertyKey, oldValue);\n        }\n\n        if (!this._hasRequestedUpdate) {\n\n            // enqueue update request if none was enqueued already\n            this._enqueueUpdate();\n        }\n\n        return this._updateRequest;\n    }\n\n    /**\n     * Updates the custom element after an update was requested with {@link requestUpdate}\n     *\n     * @remarks\n     * This method renders the template, reflects changed properties to attributes and\n     * dispatches change events for properties which are marked for notification.\n     */\n    protected update () {\n\n        this.render();\n\n        // reflect all properties marked for reflection\n        this._reflectingProperties.forEach((oldValue: any, propertyKey: PropertyKey) => {\n\n            this.reflectProperty(propertyKey, oldValue, this[propertyKey as keyof CustomElement]);\n        });\n\n        // notify all properties marked for notification\n        this._notifyingProperties.forEach((oldValue, propertyKey) => {\n\n            this.notifyProperty(propertyKey, oldValue, this[propertyKey as keyof CustomElement]);\n        });\n\n        this.updateCallback(this._changedProperties, this._hasUpdated);\n\n        this._hasUpdated = true;\n    }\n\n    /**\n     * Check if a property changed\n     *\n     * @remarks\n     * This method resolves the {@link PropertyChangeDetector} for the property and returns its result.\n     * If none is defined (the property declaration's observe option is `false`) it returns false.\n     * It catches any error in custom {@link PropertyChangeDetector}s and throws a more helpful one.\n     *\n     * @param propertyKey   The key of the property to check\n     * @param oldValue      The old property value\n     * @param newValue      The new property value\n     * @returns             `true` if the property changed, `false` otherwise\n     */\n    protected hasChanged (propertyKey: PropertyKey, oldValue: any, newValue: any): boolean {\n\n        const propertyDeclaration = this._getPropertyDeclaration(propertyKey);\n\n        // observe is either `false` or a {@link PropertyChangeDetector}\n        if (propertyDeclaration && isPropertyChangeDetector(propertyDeclaration.observe)) {\n\n            try {\n                return propertyDeclaration.observe.call(null, oldValue, newValue);\n\n            } catch (error) {\n\n                throw CHANGE_DETECTOR_ERROR(propertyDeclaration.observe);\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Reflect an attribute value to its associated property\n     *\n     * @remarks\n     * This method checks, if any custom {@link AttributeReflector} has been defined for the\n     * associated property and invokes the appropriate reflector. If not, it will use the default\n     * reflector {@link _reflectAttribute}.\n     *\n     * It catches any error in custom {@link AttributeReflector}s and throws a more helpful one.\n     *\n     * @param attributeName The propert key of the property to reflect\n     * @param oldValue      The old property value\n     * @param newValue      The new property value\n     */\n    protected reflectAttribute (attributeName: string, oldValue: string | null, newValue: string | null) {\n\n        const constructor = this.constructor as typeof CustomElement;\n\n        const propertyKey = constructor.attributes.get(attributeName);\n\n        // ignore user-defined observed attributes\n        // TODO: test this\n        if (!propertyKey) {\n\n            console.log(`observed attribute \"${ attributeName }\" not found... ignoring...`);\n\n            return;\n        }\n\n        const propertyDeclaration = this._getPropertyDeclaration(propertyKey)!;\n\n        // don't reflect if {@link propertyDeclaration.reflectAttribute} is false\n        if (propertyDeclaration.reflectAttribute) {\n\n            this._isReflecting = true;\n\n            if (isAttributeReflector(propertyDeclaration.reflectAttribute)) {\n\n                try {\n                    propertyDeclaration.reflectAttribute.call(this, attributeName, oldValue, newValue);\n\n                } catch (error) {\n\n                    throw ATTRIBUTE_REFLECTOR_ERROR(propertyDeclaration.reflectAttribute);\n                }\n\n            } else if (isPropertyKey(propertyDeclaration.reflectAttribute)) {\n\n                try {\n                    (this[propertyDeclaration.reflectAttribute] as AttributeReflector)(attributeName, oldValue, newValue);\n\n                } catch (error) {\n\n                    throw ATTRIBUTE_REFLECTOR_ERROR(propertyDeclaration.reflectAttribute);\n                }\n\n            } else {\n\n                this._reflectAttribute(attributeName, oldValue, newValue);\n            }\n\n            this._isReflecting = false;\n        }\n    }\n\n    /**\n     * Reflect a property value to its associated attribute\n     *\n     * @remarks\n     * This method checks, if any custom {@link PropertyReflector} has been defined for the\n     * property and invokes the appropriate reflector. If not, it will use the default\n     * reflector {@link _reflectProperty}.\n     *\n     * It catches any error in custom {@link PropertyReflector}s and throws a more helpful one.\n     *\n     * @param propertyKey   The propert key of the property to reflect\n     * @param oldValue      The old property value\n     * @param newValue      The new property value\n     */\n    protected reflectProperty (propertyKey: PropertyKey, oldValue: any, newValue: any) {\n\n        const propertyDeclaration = this._getPropertyDeclaration(propertyKey);\n\n        // don't reflect if {@link propertyDeclaration.reflectProperty} is false\n        if (propertyDeclaration && propertyDeclaration.reflectProperty) {\n\n            // attributeChangedCallback is called synchronously, we can catch the state there\n            this._isReflecting = true;\n\n            if (isPropertyReflector(propertyDeclaration.reflectProperty)) {\n\n                try {\n                    propertyDeclaration.reflectProperty.call(this, propertyKey, oldValue, newValue);\n\n                } catch (error) {\n\n                    throw PROPERTY_REFLECTOR_ERROR(propertyDeclaration.reflectProperty);\n                }\n\n            } else if (isPropertyKey(propertyDeclaration.reflectProperty)) {\n\n                try {\n                    (this[propertyDeclaration.reflectProperty] as PropertyReflector)(propertyKey, oldValue, newValue);\n\n                } catch (error) {\n\n                    throw PROPERTY_REFLECTOR_ERROR(propertyDeclaration.reflectProperty);\n                }\n\n            } else {\n\n                this._reflectProperty(propertyKey, oldValue, newValue);\n            }\n\n            this._isReflecting = false;\n        }\n    }\n\n    /**\n     * Raise an event for a property change\n     *\n     * @remarks\n     * This method checks, if any custom {@link PropertyNotifier} has been defined for the\n     * property and invokes the appropriate notifier. If not, it will use the default\n     * notifier {@link _notifyProperty}.\n     *\n     * It catches any error in custom {@link PropertyReflector}s and throws a more helpful one.\n     *\n     * @param propertyKey   The propert key of the property to raise an event for\n     * @param oldValue      The old property value\n     * @param newValue      The new property value\n     */\n    protected notifyProperty (propertyKey: PropertyKey, oldValue: any, newValue: any) {\n\n        const propertyDeclaration = this._getPropertyDeclaration(propertyKey);\n\n        if (propertyDeclaration && propertyDeclaration.notify) {\n\n            if (isPropertyNotifier(propertyDeclaration.notify)) {\n\n                try {\n                    propertyDeclaration.notify.call(this, propertyKey, oldValue, newValue);\n\n                } catch (error) {\n\n                    throw PROPERTY_NOTIFIER_ERROR(propertyDeclaration.notify.toString());\n                }\n\n            } else if (isPropertyKey(propertyDeclaration.notify)) {\n\n                try {\n                    (this[propertyDeclaration.notify] as PropertyNotifier)(propertyKey, oldValue, newValue);\n\n                } catch (error) {\n\n                    throw PROPERTY_NOTIFIER_ERROR(propertyDeclaration.notify);\n                }\n\n            } else {\n\n                this._notifyProperty(propertyKey, oldValue, newValue);\n            }\n        }\n    }\n\n    /**\n     * The default attribute reflector\n     *\n     * @remarks\n     * If no {@link AttributeReflector} is defined in the {@link PropertyDeclaration} this\n     * method is used to reflect the attribute value to its associated property.\n     *\n     * @param attributeName The name of the attribute to reflect\n     * @param oldValue      The old attribute value\n     * @param newValue      The new attribute value\n     *\n     * @internal\n     * @private\n     */\n    protected _reflectAttribute (attributeName: string, oldValue: string | null, newValue: string | null) {\n\n        const constructor = this.constructor as typeof CustomElement;\n\n        const propertyKey = constructor.attributes.get(attributeName)!;\n\n        const propertyDeclaration = this._getPropertyDeclaration(propertyKey)!;\n\n        const propertyValue = propertyDeclaration.converter.fromAttribute(newValue);\n\n        this[propertyKey as keyof this] = propertyValue;\n    }\n\n    /**\n     * The default property reflector\n     *\n     * @remarks\n     * If no {@link PropertyReflector} is defined in the {@link PropertyDeclaration} this\n     * method is used to reflect the property value to its associated attribute.\n     *\n     * @param propertyKey   The property key of the property to reflect\n     * @param oldValue      The old property value\n     * @param newValue      The new property value\n     *\n     * @internal\n     * @private\n     */\n    protected _reflectProperty (propertyKey: PropertyKey, oldValue: any, newValue: any) {\n\n        // this function is only called for properties which have a declaration\n        const propertyDeclaration = this._getPropertyDeclaration(propertyKey)!;\n\n        // TODO: test what happens if attribute is set to false but reflectProperty is true!\n        const attributeName = propertyDeclaration.attribute as string;\n        // resolve the attribute value\n        const attributeValue = propertyDeclaration.converter.toAttribute(newValue);\n\n        // undefined means don't change\n        if (attributeValue === undefined) {\n\n            return;\n        }\n        // null means remove the attribute\n        else if (attributeValue === null) {\n\n            this.removeAttribute(attributeName);\n\n        } else {\n\n            this.setAttribute(attributeName, attributeValue);\n        }\n    }\n\n    /**\n     * Dispatch a property-changed event\n     *\n     * @param propertyKey\n     * @param oldValue\n     * @param newValue\n     */\n    protected _notifyProperty (propertyKey: PropertyKey, oldValue: any, newValue: any): void {\n\n        const eventName = createEventName(propertyKey, '', 'changed');\n\n        this.dispatchEvent(new CustomEvent(eventName, {\n            composed: true,\n            detail: {\n                property: propertyKey,\n                previous: oldValue,\n                current: newValue\n            }\n        }));\n    }\n\n    /**\n     * Dispatch a lifecycle event\n     *\n     * @param lifecycle The lifecycle for which to raise the event\n     * @param detail    Optional event details\n     */\n    protected _notifyLifecycle (lifecycle: string, detail?: object) {\n\n        const eventName = createEventName(lifecycle, 'on');\n\n        const eventInit = {\n            composed: true,\n            ...(detail ? { detail: detail } : {})\n        };\n\n        this.dispatchEvent(new CustomEvent(eventName, eventInit));\n    }\n\n    /**\n     * Bind custom element listeners.\n     *\n     * @internal\n     * @private\n     */\n    protected _listen () {\n\n        (this.constructor as typeof CustomElement).listeners.forEach((declaration, listener) => {\n\n            const instanceDeclaration: InstanceListenerDeclaration = {\n\n                // copy the class's static listener declaration into an instance listener declaration\n                event: declaration.event,\n                options: declaration.options,\n\n                // bind the components listener method to the component instance and store it in the instance declaration\n                listener: (this[listener as keyof this] as unknown as EventListener).bind(this),\n\n                // determine the event target and store it in the instance declaration\n                target: (declaration.target) ?\n                    (typeof declaration.target === 'function') ?\n                        declaration.target() :\n                        declaration.target :\n                    this\n            };\n\n            // add the bound event listener to the target\n            instanceDeclaration.target.addEventListener(instanceDeclaration.event as string, instanceDeclaration.listener, instanceDeclaration.options);\n\n            // save the instance listener declaration on the component instance\n            this._listenerDeclarations.push(instanceDeclaration);\n        });\n    }\n\n    /**\n     * Unbind custom element listeners.\n     *\n     * @internal\n     * @private\n     */\n    protected _unlisten () {\n\n        this._listenerDeclarations.forEach((declaration) => {\n\n            declaration.target.removeEventListener(declaration.event as string, declaration.listener, declaration.options);\n        });\n    }\n\n    /**\n     * Schedule the update of the custom element\n     *\n     * @remarks\n     * Schedules the update of the custom element just before the next frame\n     * and cleans up the custom elements state afterwards.\n     */\n    protected _scheduleUpdate (): Promise<void> {\n\n        return new Promise(resolve => {\n\n            // schedule the update via requestAnimationFrame to avoid multiple redraws per frame\n            requestAnimationFrame(() => {\n\n                this.update();\n\n                this._changedProperties = new Map();\n\n                this._reflectingProperties = new Map();\n\n                this._notifyingProperties = new Map();\n\n                // mark custom element as updated after the update to prevent infinte loops in the update process\n                // N.B.: any property changes during the update will be ignored\n                this._hasRequestedUpdate = false;\n\n                resolve();\n            });\n        });\n    }\n\n    /**\n     * Enqueue a request for an asynchronous update\n     */\n    private async _enqueueUpdate () {\n\n        let resolve: (result: boolean) => void;\n\n        const previousRequest = this._updateRequest;\n\n        // mark the custom element as having requested an update, the {@link _requestUpdate} method\n        // will not enqueue a further request for update if one is scheduled\n        this._hasRequestedUpdate = true;\n\n        this._updateRequest = new Promise<boolean>(res => resolve = res);\n\n        // wait for the previous update to resolve\n        // `await` is asynchronous and will return execution to the {@link requestUpdate} method\n        // and essentially allows us to batch multiple synchronous property changes, before the\n        // execution can resume here\n        await previousRequest;\n\n        const result = this._scheduleUpdate();\n\n        // the actual update is scheduled asynchronously as well\n        await result;\n\n        // resolve the new {@link _updateRequest} after the result of the current update resolves\n        resolve!(!this._hasRequestedUpdate);\n    }\n\n    /**\n     * Gets the {@link PropertyDeclaration} for a decorated property\n     *\n     * @param propertyKey The property key for which to retrieve the declaration\n     *\n     * @internal\n     * @private\n     */\n    private _getPropertyDeclaration (propertyKey: PropertyKey): PropertyDeclaration | undefined {\n\n        return (this.constructor as typeof CustomElement).properties.get(propertyKey);\n    }\n}\n","import { CustomElement } from '../custom-element';\nimport { DecoratedCustomElementType } from './property';\n\n/**\n * A {@link CustomElement} declaration\n */\nexport interface CustomElementDeclaration {\n    /**\n     * The selector of the custom element\n     *\n     * @remarks\n     * The selector will be used to register the custom element constructor with the browser's\n     * {@link window.customElements} API. If no selector is specified, the custom element class\n     * needs to provide one in its static {@link CustomElement.selector} property.\n     * A selector defined in the {@link CustomElementDeclaration} will take precedence over the\n     * static class property.\n     */\n    selector: string;\n\n    /**\n     * Use Shadow DOM to render the custom elements template?\n     *\n     * @remarks\n     * Shadow DOM can be disabled by setting this option to `false`, in which case the custom\n     * element's template will be rendered as child nodes of the custom element. This can be\n     * useful if an isolated DOM and scoped CSS is not desired.\n     *\n     * Default value: `true`\n     */\n    shadow: boolean;\n\n    /**\n     * Automatically register the custom element with the browser's {@link window.customElements} API?\n     *\n     * @remarks\n     * In cases where you want to employ a module system which registers custom elements on\n     * a conditional basis, you can disable automatic registration by setting this option to\n     * `false`. Your module or bootstrap system will have to take care of defining the custom\n     * element later.\n     *\n     * Default value: `true`\n     */\n    define: boolean;\n}\n\nexport const DEFAULT_CUSTOM_ELEMENT_DECLARATION: CustomElementDeclaration = {\n    selector: '',\n    shadow: true,\n    define: true\n};\n\n/**\n * Decorates a {@link CustomElement} class\n *\n * @param options A custom element declaration\n */\nexport const customElement = (options: Partial<CustomElementDeclaration> = {}) => {\n\n    const declaration = { ...DEFAULT_CUSTOM_ELEMENT_DECLARATION, ...options };\n\n    return (target: typeof CustomElement) => {\n\n        const constructor = target as DecoratedCustomElementType;\n\n        constructor.selector = declaration.selector || target.selector;\n        constructor.shadow = declaration.shadow;\n\n        /**\n         * Property decorators get called before class decorators, so at this point all decorated properties\n         * have stored their associated attributes in {@link CustomElement.attributes}.\n         * We can now combine them with the user-defined {@link CustomElement.observedAttributes} and,\n         * by using a Set, eliminate all duplicates in the process.\n         *\n         * As the user-defined {@link CustomElement.observedAttributes} will also include decorator generated\n         * observed attributes, we always inherit all observed attributes from a base class. For that reason\n         * we have to keep track of attribute overrides when extending any {@link CustomElement} base class.\n         * This is done in the {@link property} decorator. Here we have to make sure to remove overridden\n         * attributes.\n         */\n        const observedAttributes = [\n            ...new Set(\n                // we take the inherited observed attributes...\n                constructor.observedAttributes\n                    // ...remove overridden generated attributes...\n                    .reduce((attributes, attribute) => attributes.concat(\n                        constructor.overridden && constructor.overridden.has(attribute) ? [] : attribute),\n                        [] as string[]\n                    )\n                    // ...and recombine the list with the newly generated attributes (the Set prevents duplicates)\n                    .concat([...target.attributes.keys()])\n            )\n        ];\n\n        // TODO: delete the overridden Set from the constructor\n\n        /**\n         * Finally we override the {@link CustomElement.observedAttributes} getter with a new one, which returns\n         * the unique set of user defined and decorator generated observed attributes.\n         *\n         * N.B.: When extending an existing custom element, and oerriding a property with a different associated\n         * attribute name, the base class's original attribute name remains in the {@link CustomElement.observedAttributes}\n         * array. Changing the old attribute on the extended class will try to reflect the attribute, but won't\n         * find the attribute in the extended class's {@link CustomElement.attributes} Map and will therefore be\n         * ignored.\n         */\n        Reflect.defineProperty(constructor, 'observedAttributes', {\n            configurable: true,\n            enumerable: false,\n            get (): string[] {\n                return observedAttributes;\n            }\n        });\n\n        if (declaration.define) {\n\n            window.customElements.define(constructor.selector, constructor);\n        }\n    };\n};\n","import { CustomElement } from '../custom-element';\n\n/**\n * A {@link CustomElement} event listener declaration\n */\nexport interface ListenerDeclaration {\n\n    /**\n     * The event to listen to\n     *\n     * @remarks\n     * Setting event to `null` allows to unbind an inherited event listener.\n     */\n    event: string | null;\n\n    /**\n     * An options object that specifies characteristics about the event listener\n     */\n    options?: AddEventListenerOptions;\n\n    /**\n     * An alternative event target (by default this will be the {@link CustomElement} instance)\n     *\n     * @remarks\n     * This can be useful if you want to listen to e.g.:\n     * * window.onresize\n     * * document.onload\n     * * document.onscroll\n     * * Worker.onmessage - TODO: This could be interesting to solve, we might need to get the worker from the\n     *   component instance, maybe a use case for di @self()\n     */\n    target?: EventTarget | (() => EventTarget);\n}\n\n/**\n * Decorates a {@link CustomElement} method as an event listener\n *\n * @param options The listener declaration\n */\nexport function listener (options: ListenerDeclaration) {\n\n    return function (target: Object, propertyKey: string, descriptor: PropertyDescriptor) {\n\n        const constructor = target.constructor as typeof CustomElement;\n\n        prepareConstructor(constructor);\n\n        if (options.event === null) {\n\n            constructor.listeners.delete(propertyKey);\n\n        } else {\n\n            constructor.listeners.set(propertyKey, { ...options });\n        }\n    }\n}\n\n/**\n * Prepares the custom element constructor by initializing static properties for the listener decorator,\n * so we don't modify a base class's static properties.\n *\n * @remarks\n * When the listener decorator stores listener declarations in the constructor, we have to make sure the\n * static listeners field is initialized on the current constructor. Otherwise we add listener declarations\n * to the base class's static field. We also make sure to initialize the listener maps with the values of\n * the base class's map to properly inherit all listener declarations.\n *\n * @param constructor The custom element constructor to prepare\n *\n * @internal\n * @private\n */\nfunction prepareConstructor (constructor: typeof CustomElement) {\n\n    if (!constructor.hasOwnProperty('listeners')) constructor.listeners = new Map(constructor.listeners);\n}\n","/**\n * Get the {@link PropertyDescriptor} of a property from its prototype\n * or a parent prototype - excluding {@link Object.prototype} itself, to\n * ensure correct prototype inheritance.\n *\n * @param target        The prototype to get the descriptor from\n * @param propertyKey   The property key for which to get the descriptor\n *\n * @internal\n * @private\n */\nexport function getPropertyDescriptor (target: Object, propertyKey: PropertyKey): PropertyDescriptor | undefined {\n\n    if (propertyKey in target) {\n\n        while (target !== Object.prototype) {\n\n            if (target.hasOwnProperty(propertyKey)) {\n\n                return Object.getOwnPropertyDescriptor(target, propertyKey);\n            }\n\n            target = Object.getPrototypeOf(target);\n        }\n    }\n\n    return undefined;\n}\n","import { CustomElement } from '../custom-element';\nimport { getPropertyDescriptor } from './get-property-descriptor';\nimport { createAttributeName, DEFAULT_PROPERTY_DECLARATION, PropertyDeclaration } from './property-declaration';\n\n/**\n * A type extension to add additional properties to a {@link CustomElement} constructor during decoration\n *\n * @internal\n * @private\n */\nexport type DecoratedCustomElementType = typeof CustomElement & { overridden?: Set<string> };\n\n/**\n * Decorates a {@link CustomElement} property\n *\n * @remarks\n * Many of the {@link PropertyDeclaration} options support custom functions, which will be invoked\n * with the custom element instance as `this`-context during execution. In order to support correct\n * typing in these functions, the `@property` decorator supports generic types. Here is an example\n * of how you can use this with a custom {@link PropertyReflector}:\n *\n * ```typescript\n * class MyElement extends CustomElement {\n *\n *      myHiddenProperty = true;\n *\n *      // use a generic to support proper instance typing in the property reflector\n *      @property<MyElement>({\n *          reflectProperty: (propertyKey: string, oldValue: any, newValue: any) {\n *              // the generic type allows for correct typing of this\n *              if (this.myHiddenProperty && newValue) {\n *                  this.setAttribute('my-property', '');\n *              } else {\n *                  this.removeAttribute('my-property');\n *              }\n *          }\n *      })\n *      myProperty = false;\n * }\n * ```\n *\n * @param options A property declaration\n */\nexport const property = <Type extends CustomElement = CustomElement> (options: Partial<PropertyDeclaration<Type>> = {}) => {\n\n    return (target: Object, propertyKey: PropertyKey): void => {\n\n        const descriptor = getPropertyDescriptor(target, propertyKey);\n        const hiddenKey = (typeof propertyKey === 'string') ? `_${ propertyKey }` : Symbol();\n        const get = descriptor && descriptor.get || function (this: any) { return this[hiddenKey]; };\n        const set = descriptor && descriptor.set || function (this: any, value: any) { this[hiddenKey] = value; };\n\n        Object.defineProperty(target, propertyKey, {\n            configurable: true,\n            enumerable: true,\n            get (): any {\n                return get.call(this);\n            },\n            set (value: any): void {\n                const oldValue = this[propertyKey];\n                set.call(this, value);\n                this.requestUpdate(propertyKey, oldValue, value);\n            }\n        });\n\n        const constructor = target.constructor as DecoratedCustomElementType;\n\n        const declaration: PropertyDeclaration<Type> = { ...DEFAULT_PROPERTY_DECLARATION, ...options };\n\n        // generate the default attribute name\n        if (declaration.attribute === true) {\n\n            declaration.attribute = createAttributeName(propertyKey);\n        }\n\n        // set the default property change detector\n        if (declaration.observe === true) {\n\n            declaration.observe = DEFAULT_PROPERTY_DECLARATION.observe;\n        }\n\n        prepareConstructor(constructor);\n\n        // check if we inherited an observed attribute for the property from the base class\n        const attribute = constructor.properties.has(propertyKey) ? constructor.properties.get(propertyKey)!.attribute : undefined;\n\n        // if attribute is truthy it's a string and it will exist in the attributes map\n        if (attribute) {\n\n            // remove the inherited attribute as it's overridden\n            constructor.attributes.delete(attribute as string);\n\n            // mark attribute as overridden for {@link customElement} decorator\n            constructor.overridden!.add(attribute as string);\n        }\n\n        if (declaration.attribute) {\n\n            constructor.attributes.set(declaration.attribute, propertyKey);\n        }\n\n        // store the property declaration last, so we can still access the inherited declaration\n        // when processing the attributes\n        constructor.properties.set(propertyKey, declaration as PropertyDeclaration);\n    };\n};\n\n/**\n * Prepares the custom element constructor by initializing static properties for the property decorator,\n * so we don't modify a base class's static properties.\n *\n * @remarks\n * When the property decorator stores property declarations and attribute mappings in the constructor,\n * we have to make sure those static fields are initialized on the current constructor. Otherwise we\n * add property declarations and attribute mappings to the base class's static fields. We also make\n * sure to initialize the constructors maps with the values of the base class's maps to properly\n * inherit all property declarations and attributes.\n *\n * @param constructor The custom element constructor to prepare\n *\n * @internal\n * @private\n */\nfunction prepareConstructor (constructor: DecoratedCustomElementType) {\n\n    // this will give us a compile-time error if we refactor one of the static constructor properties\n    // and we won't miss renaming the property keys\n    const properties: keyof DecoratedCustomElementType = 'properties';\n    const attributes: keyof DecoratedCustomElementType = 'attributes';\n    const overridden: keyof DecoratedCustomElementType = 'overridden';\n\n    if (!constructor.hasOwnProperty(properties)) constructor.properties = new Map(constructor.properties);\n    if (!constructor.hasOwnProperty(attributes)) constructor.attributes = new Map(constructor.attributes);\n    if (!constructor.hasOwnProperty(overridden)) constructor.overridden = new Set();\n}\n"],"names":["SPACES","CAMELS","kebabCase","string","matches","trim","exec","replace","lastIndex","toLowerCase","AttributeConverterDefault","fromAttribute","value","JSON","parse","error","toAttribute","stringify","toString","AttributeConverterBoolean","AttributeConverterString","AttributeConverterNumber","Number","AttributeConverterObject","AttributeConverterArray","AttributeConverterDate","Date","isAttributeReflector","reflector","isPropertyReflector","isPropertyNotifier","notifier","isPropertyChangeDetector","detector","isPropertyKey","key","encodeAttribute","createAttributeName","propertyKey","String","createEventName","prefix","suffix","propertyString","DEFAULT_PROPERTY_CHANGE_DETECTOR","oldValue","newValue","DEFAULT_PROPERTY_DECLARATION","attribute","converter","reflectAttribute","reflectProperty","notify","observe","ATTRIBUTE_REFLECTOR_ERROR","attributeReflector","Error","PROPERTY_REFLECTOR_ERROR","propertyReflector","PROPERTY_NOTIFIER_ERROR","propertyNotifier","CHANGE_DETECTOR_ERROR","changeDetector","CustomElement","HTMLElement","[object Object]","super","this","Promise","resolve","Map","_renderRoot","createRenderRoot","observedAttributes","isConnected","_isConnected","_notifyLifecycle","_listen","requestUpdate","_unlisten","_isReflecting","changedProperties","firstUpdate","constructor","shadow","attachShadow","mode","template","render","executor","previousChanges","_changedProperties","has","hasChanged","get","_notifyingProperties","set","_updateRequest","_reflectingProperties","_hasRequestedUpdate","_enqueueUpdate","forEach","notifyProperty","updateCallback","_hasUpdated","propertyDeclaration","_getPropertyDeclaration","call","attributeName","attributes","console","log","_reflectAttribute","_reflectProperty","_notifyProperty","propertyValue","attributeValue","undefined","removeAttribute","setAttribute","eventName","dispatchEvent","CustomEvent","composed","detail","property","previous","current","lifecycle","eventInit","listeners","declaration","listener","instanceDeclaration","event","options","bind","target","addEventListener","_listenerDeclarations","push","removeEventListener","requestAnimationFrame","update","previousRequest","res","result","_scheduleUpdate","properties","DEFAULT_CUSTOM_ELEMENT_DECLARATION","selector","define","customElement","Set","reduce","concat","overridden","keys","Reflect","defineProperty","configurable","enumerable","window","customElements","descriptor","prepareConstructor","delete","hasOwnProperty","getPropertyDescriptor","Object","prototype","getOwnPropertyDescriptor","getPrototypeOf","hiddenKey","Symbol","add"],"mappings":"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"}