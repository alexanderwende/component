{"version":3,"file":"index.cjs.js","sources":["../src/utils/string-utils.ts","../src/custom-element.ts","../src/decorators/custom-element.ts","../src/decorators/property.ts"],"sourcesContent":["const FIRST = /^[^]/;\nconst SPACES = /\\s+([\\S])/g;\nconst CAMELS = /[a-z]([A-Z])/g;\nconst KEBABS = /-([a-z])/g;\n\nexport function capitalize (string: string): string {\n\n    return string ? string.replace(FIRST, string[0].toUpperCase()) : string;\n}\n\nexport function uncapitalize (string: string): string {\n\n    return string ? string.replace(FIRST, string[0].toLowerCase()) : string;\n}\n\nexport function camelCase (string: string): string {\n\n    let matches;\n\n    if (string) {\n\n        string = string.trim();\n\n        while ((matches = SPACES.exec(string))) {\n\n            string = string.replace(matches[0], matches[1].toUpperCase());\n\n            SPACES.lastIndex = 0;\n        }\n\n        while ((matches = KEBABS.exec(string))) {\n\n            string = string.replace(matches[0], matches[1].toUpperCase());\n\n            KEBABS.lastIndex = 0;\n        }\n    }\n\n    return uncapitalize(string);\n}\n\nexport function kebabCase (string: string): string {\n\n    let matches;\n\n    if (string) {\n\n        string = string.trim();\n\n        while ((matches = SPACES.exec(string))) {\n\n            string = string.replace(matches[0], '-' + matches[1]);\n\n            SPACES.lastIndex = 0;\n        }\n\n        while ((matches = CAMELS.exec(string))) {\n\n            string = string.replace(matches[0], matches[0][0] + '-' + matches[1]);\n\n            CAMELS.lastIndex = 0;\n        }\n    }\n\n    return string ? string.toLowerCase() : string;\n}\n","import { html, render, TemplateResult } from 'lit-html';\nimport { PropertyDeclaration, PropertyReflector, PropertyNotifier } from './decorators/property';\nimport { kebabCase } from './utils/string-utils';\nimport { ListenerDeclaration } from './decorators/listener';\n\nconst PROPERTY_REFLECTOR_ERROR = (propertyReflector: string) => new Error(`Error executing property reflector ${ propertyReflector }.`);\nconst PROPERTY_NOTIFIER_ERROR = (propertyNotifier: string) => new Error(`Error executing property notifier ${ propertyNotifier }.`);\n\n/**\n * Extends the static {@link ListenerDeclaration} to include the bound listener\n */\ninterface InstanceListenerDeclaration extends ListenerDeclaration {\n\n    /**\n     * The bound listener will be stored here, so it can be removed it later\n     */\n    listener: EventListener;\n\n    /**\n     * The event target will always be resolved to an actual {@link EventTarget}\n     */\n    target: EventTarget;\n}\n\nexport interface CustomElementType<T extends CustomElement = CustomElement> {\n\n    selector: string;\n\n    shadow: boolean;\n\n    propertyDeclarations: { [key: string]: PropertyDeclaration<T> };\n\n    listenerDeclarations: { [key: string]: ListenerDeclaration };\n\n    new(...args: any[]): T;\n}\n\nexport class CustomElement extends HTMLElement {\n\n    static selector: string;\n\n    static shadow: boolean;\n\n    static propertyDeclarations: { [key: string]: PropertyDeclaration } = {};\n\n    static listenerDeclarations: { [key: string]: ListenerDeclaration } = {};\n\n    static get observedAttributes (): string[] {\n\n        return [];\n    }\n\n    protected _renderRoot: Element | DocumentFragment;\n\n    protected _updateRequest: Promise<boolean> = Promise.resolve(true);\n\n    protected _changedProperties: Map<string, any> = new Map();\n\n    protected _notifyingProperties: Map<string, any> = new Map();\n\n    protected _listenerDeclarations: InstanceListenerDeclaration[] = [];\n\n    protected _isConnected = false;\n\n    protected _hasRequestedUpdate = false;\n\n    protected _isReflecting = false;\n\n    get isConnected (): boolean {\n\n        return this._isConnected;\n    }\n\n    constructor () {\n\n        super();\n\n        this._renderRoot = this.createRenderRoot();\n\n        console.log('constructed... ', this.constructor.name);\n    }\n\n    createRenderRoot (): Element | DocumentFragment {\n\n        return (this.constructor as CustomElementType).shadow ?\n            this.attachShadow({ mode: 'open' }) :\n            this;\n    }\n\n    adoptedCallback (): void {\n    }\n\n    connectedCallback (): void {\n\n        console.log('connected... ', this.constructor.name);\n\n        this._listen();\n\n        this.requestUpdate();\n    }\n\n    disconnectedCallback (): void {\n\n        console.log('disconnected... ', this.constructor.name);\n\n        this._unlisten();\n    }\n\n    attributeChangedCallback (attribute: string, oldValue: any, newValue: any): void {\n    }\n\n    propertyChangedCallback (property: string, oldValue: any, newValue: any): void {\n    }\n\n    template (): TemplateResult {\n\n        return html``;\n    }\n\n    render (): void {\n\n        console.log('render()... ', this.constructor.name);\n\n        render(this.template(), this._renderRoot);\n\n        this.renderCallback();\n    }\n\n    renderCallback (): void {\n\n        console.log('rendered... ', this.constructor.name);\n    }\n\n    update (changedProperties: Map<string, any>): void {\n\n        console.log('update()... ', changedProperties);\n\n        this.render();\n\n        changedProperties.forEach((oldValue: any, propertyKey: string) => {\n\n            // properties in the changedProperties map will always have a declaration\n            const propertyDeclaration = this._getPropertyDeclaration(propertyKey)!;\n            const newValue = this[propertyKey as keyof CustomElement];\n\n            // TODO: only reflect if property change was not initiated by observed attribute\n            if (propertyDeclaration.reflect) {\n\n                if (typeof propertyDeclaration.reflect === 'function') {\n\n                    try {\n                        propertyDeclaration.reflect.call(this, propertyKey, oldValue, newValue);\n                    } catch (error) {\n                        throw PROPERTY_REFLECTOR_ERROR(propertyDeclaration.reflect.toString());\n                    }\n\n                } else if (typeof propertyDeclaration.reflect === 'string') {\n\n                    try {\n                        (this[propertyDeclaration.reflect as keyof this] as unknown as PropertyReflector)(propertyKey, oldValue, newValue);\n                    } catch (error) {\n                        throw PROPERTY_REFLECTOR_ERROR(propertyDeclaration.reflect);\n                    }\n\n                } else {\n\n                    this._reflect(propertyKey, oldValue, newValue);\n                }\n            }\n        });\n\n        this._notifyingProperties.forEach((oldValue, propertyKey) => {\n\n            const propertyDeclaration = this._getPropertyDeclaration(propertyKey)!;\n            const newValue = this[propertyKey as keyof CustomElement];\n\n            if (propertyDeclaration.notify) {\n\n                if (typeof propertyDeclaration.notify === 'function') {\n\n                    try {\n                        propertyDeclaration.notify.call(this, propertyKey, oldValue, newValue);\n                    } catch (error) {\n                        throw PROPERTY_NOTIFIER_ERROR(propertyDeclaration.notify.toString());\n                    }\n\n                } else if (typeof propertyDeclaration.notify === 'string') {\n\n                    try {\n                        (this[propertyDeclaration.notify as keyof this] as unknown as PropertyNotifier)(propertyKey, oldValue, newValue);\n                    } catch (error) {\n                        throw PROPERTY_NOTIFIER_ERROR(propertyDeclaration.notify);\n                    }\n\n                } else {\n\n                    this._notify(propertyKey, oldValue, newValue);\n                }\n            }\n        });\n    }\n\n    /**\n     * Raise custom events for property changes which occurred in the executor\n     *\n     * @remarks\n     * Property changes should trigger custom events when they are caused by internal state changes,\n     * but not if they are caused by a consumer of the custom element API directly, e.g.:\n     *\n     * ```typescript\n     * document.querySelector('my-custom-element').customProperty = true;\n     * ```.\n     *\n     * This means, we cannot automate this process through property setters, as we can't be sure who\n     * invoked the setter - internal calls or external calls.\n     *\n     * One option is to manually raise the event, which can become tedious and forces us to use string-\n     * based event names or property names, which are difficult to refactor, e.g.:\n     *\n     * ```typescript\n     * this.customProperty = true;\n     * // if we refactor the property name, we can easily miss the notify call\n     * this.notify('customProperty');\n     * ```\n     *\n     * A more convenient way is to execute the internal changes in a wrapper which can detect the changed\n     * properties and will automatically raise the required events. This eliminates the need to manually\n     * raise events and refactoring does no longer affect the process.\n     *\n     * @param executor A function that performs the changes which should be notified\n     */\n    notifyChanges (executor: () => void) {\n\n        // back up current changed properties\n        const previousChanges = new Map(this._changedProperties);\n\n        // execute the changes\n        executor();\n\n        // add all new or updated changed properties to the notifying properties\n        for (const [propertyKey, oldValue] of this._changedProperties) {\n\n            if (!previousChanges.has(propertyKey) || previousChanges.get(propertyKey) !== oldValue) {\n\n                this._notifyingProperties.set(propertyKey, oldValue);\n            }\n        }\n    }\n\n    /**\n     * Dispatch a property-changed event.\n     *\n     * @param propertyKey\n     * @param oldValue\n     * @param newValue\n     */\n    protected _notify (propertyKey: string, oldValue: any, newValue: any): void {\n\n        const eventName = `${ kebabCase(propertyKey) }-changed`;\n\n        this.dispatchEvent(new CustomEvent(eventName, {\n            composed: true,\n            detail: {\n                property: propertyKey,\n                previous: oldValue,\n                current: newValue\n            }\n        }));\n\n        console.log(`notify ${ eventName }...`);\n    }\n\n    /**\n     * Reflect a property to an attribute on the custom element.\n     *\n     * @param propertyKey\n     * @param oldValue\n     * @param newValue\n     *\n     * @internal\n     * @private\n     */\n    protected _reflect (propertyKey: string, oldValue: any, newValue: any): void {\n\n        const propertyDeclaration = this._getPropertyDeclaration(propertyKey)!;\n\n        // resolve the attribute name\n        const attributeName = propertyDeclaration.attribute || kebabCase(propertyKey);\n        // resolve the attribute value\n        const attributeValue = propertyDeclaration.toAttribute!(newValue);\n\n        if (attributeValue === null) {\n\n            this.removeAttribute(attributeName);\n\n        } else {\n\n            this.setAttribute(attributeName, attributeValue);\n        }\n    }\n\n    /**\n     * Bind custom element listeners.\n     *\n     * @internal\n     * @private\n     */\n    protected _listen () {\n\n        Object.entries((this.constructor as CustomElementType).listenerDeclarations).forEach(([listener, declaration]) => {\n\n            const instanceDeclaration: InstanceListenerDeclaration = {\n\n                // copy the class's static listener declaration into an instance listener declaration\n                event: declaration.event,\n                options: declaration.options,\n\n                // bind the components listener method to the component instance and store it in the instance declaration\n                listener: (this[listener as keyof this] as unknown as EventListener).bind(this),\n\n                // determine the event target and store it in the instance declaration\n                target: (declaration.target) ?\n                    (typeof declaration.target === 'function') ?\n                        declaration.target() :\n                        declaration.target :\n                    this\n            };\n\n            // add the bound event listener to the target\n            instanceDeclaration.target.addEventListener(instanceDeclaration.event, instanceDeclaration.listener, instanceDeclaration.options);\n\n            // save the instance listener declaration on the component instance\n            this._listenerDeclarations.push(instanceDeclaration);\n        });\n    }\n\n    /**\n     * Unbind custom element listeners.\n     *\n     * @internal\n     * @private\n     */\n    protected _unlisten () {\n\n        this._listenerDeclarations.forEach((declaration) => {\n\n            declaration.target.removeEventListener(declaration.event, declaration.listener, declaration.options);\n        });\n    }\n\n    requestUpdate (propertyKey?: string, oldValue?: any, newValue?: any): Promise<boolean> {\n\n        console.log('requestUpdate()... ', this.constructor.name);\n\n        const constructor = this.constructor as typeof CustomElement;\n\n        if (propertyKey && propertyKey in constructor.propertyDeclarations) {\n\n            const propertyDeclaration = constructor.propertyDeclarations[propertyKey];\n\n            // check if property is observed\n            console.log(`requestUpdate()... ${ propertyKey } observe: ${ propertyDeclaration.observe }`);\n            if (!propertyDeclaration.observe) return this._updateRequest;\n\n            // check if property has changed\n            if (propertyDeclaration.hasChanged && !propertyDeclaration.hasChanged(oldValue, newValue)) return this._updateRequest;\n\n            // store changed property for batch processing\n            this._changedProperties.set(propertyKey, oldValue);\n        }\n\n        if (!this._hasRequestedUpdate) {\n\n            // enqueue update request if none was enqueued already\n            this._enqueueUpdate();\n        }\n\n        return this._updateRequest;\n    }\n\n    protected _performUpdate (): Promise<void> {\n\n        console.log('performUpdate()... ', this.constructor.name);\n\n        return new Promise(resolve => {\n\n            requestAnimationFrame(() => {\n\n                this.update(this._changedProperties);\n\n                this._changedProperties = new Map();\n\n                this._notifyingProperties = new Map();\n\n                // TODO: Should this be moved before the update call?\n                // During the update, other property changes might occur...\n                this._hasRequestedUpdate = false;\n\n                resolve();\n            });\n        });\n    }\n\n    private async _enqueueUpdate () {\n\n        console.log('enqueueUpdate()... ', this.constructor.name);\n\n        let resolve: (result: boolean) => void;\n\n        const previousRequest = this._updateRequest;\n\n        this._hasRequestedUpdate = true;\n\n        this._updateRequest = new Promise<boolean>(res => resolve = res);\n\n        await previousRequest;\n\n        const result = this._performUpdate();\n\n        await result;\n\n        resolve!(!this._hasRequestedUpdate);\n    }\n\n    private _getPropertyDeclaration (propertyKey: string): PropertyDeclaration | undefined {\n\n        return (this.constructor as typeof CustomElement).propertyDeclarations[propertyKey];\n    }\n}\n","import { CustomElementType } from '../custom-element';\n\nexport interface CustomElementDeclaration extends Object {\n    selector?: string;\n    shadow?: boolean;\n    define?: boolean;\n}\n\nexport const DEFAULT_CUSTOM_ELEMENT_DECLARATION: CustomElementDeclaration = {\n    selector: '',\n    shadow: true,\n    define: true\n};\n\nexport const customElement = (options: CustomElementDeclaration = {}) => {\n\n    options = { ...DEFAULT_CUSTOM_ELEMENT_DECLARATION, ...options };\n\n    return (target: CustomElementType) => {\n\n        target.selector = (options.selector) ? options.selector : target.selector;\n        target.shadow = options.shadow!;\n\n        if (options.define) {\n\n            window.customElements.define(target.selector, target);\n        }\n    };\n};\n","import { CustomElementType, CustomElement } from '../custom-element';\n\nexport type PropertyReflector<Type extends CustomElement = CustomElement> = (this: Type, propertyKey: string, oldValue: any, newValue: any) => void;\n\nexport type PropertyNotifier<Type extends CustomElement = CustomElement> = (this: Type, propertyKey: string, oldValue: any, newValue: any) => void;\n\n/**\n * A {@link CustomElement} property declaration\n *\n * @property observe    True if the property change should be observed and cause an update\n * @property notify     True if the property change should trigger a custom event\n */\nexport interface PropertyDeclaration<Type extends CustomElement = CustomElement> {\n    /**\n     * The name of the associated attribute\n     *\n     * @remarks\n     * Will be the camel-cased property name if not specified.\n     */\n    attribute?: string;\n    observe?: boolean,\n    notify?: boolean | keyof Type | PropertyNotifier<Type>,\n    /**\n     * Controls how the property value will be reflected to attributes\n     *\n     * TODO: Improve description\n     * @remarks\n     * If true -> will be reflected automatically\n     * If string -> will pick up method from custom element\n     * If function -> will use that function with this being bound to custom element instance\n     *\n     * ```typescript\n     * class MyElement extends CustomElement {\n     *      // use a generic to support proper instance typing in the property reflector\n     *      @property<MyElement>({\n     *          reflect: (propertyKey: string, oldValue: any, newValue: any) {\n     *              // do something here with those values\n     *          }\n     *      })\n     *      myProperty = false;\n     * }\n     * ```\n     */\n    reflect?: boolean | keyof Type | PropertyReflector<Type>,\n    hasChanged?: (oldValue: any, newValue: any) => boolean;\n    toAttribute?: (value: any) => string | null;\n    fromAttribute?: (value: string) => any;\n}\n\n/**\n * The default {@link CustomElement} property declaration\n */\nexport const DEFAULT_PROPERTY_DECLARATION: PropertyDeclaration = {\n    observe: true,\n    notify: false,\n    reflect: false,\n    hasChanged: (oldValue: any, newValue: any) => oldValue !== newValue && (oldValue === oldValue || newValue === newValue),\n    toAttribute: value => value.toString(),\n    fromAttribute: value => value\n};\n\n/**\n * Decorates a {@link CustomElement} property\n *\n * @param options The property declaration\n */\nexport const property = <Type extends CustomElement = CustomElement>(options: PropertyDeclaration<Type> = {}) => {\n\n    return (target: Object, propertyKey: string): void => {\n\n        const descriptor = getPropertyDescriptor(target, propertyKey);\n        const hiddenKey = (typeof propertyKey === 'string') ? `_${ propertyKey }` : Symbol();\n        const get = descriptor && descriptor.get || function (this: any) { return this[hiddenKey]; };\n        const set = descriptor && descriptor.set || function (this: any, value: any) { this[hiddenKey] = value; };\n\n        Object.defineProperty(target, propertyKey, {\n            configurable: true,\n            enumerable: true,\n            get (): any {\n                return get.call(this);\n            },\n            set (value: any): void {\n                console.log(`setting ${propertyKey}...`, value);\n                const oldValue = this[propertyKey];\n                set.call(this, value);\n                this.requestUpdate(propertyKey, oldValue, value);\n            }\n        });\n\n        const constructor = target.constructor as CustomElementType<Type>;\n\n        constructor.propertyDeclarations[propertyKey] = { ...DEFAULT_PROPERTY_DECLARATION, ...options };\n    };\n};\n\n/**\n * Get the {@link PropertyDescriptor} of a property from its prototype\n * or a parent prototype - excluding {@link Object.prototype} itself, to\n * ensure correct prototype inheritance.\n *\n * @param target        The prototype to get the descriptor from\n * @param propertyKey   The property key for which to get the descriptor\n *\n * @internal\n * @private\n */\nfunction getPropertyDescriptor (target: Object, propertyKey: string | symbol): PropertyDescriptor | undefined {\n\n    if (propertyKey in target) {\n\n        while (target !== Object.prototype) {\n\n            if (target.hasOwnProperty(propertyKey)) {\n\n                return Object.getOwnPropertyDescriptor(target, propertyKey);\n            }\n\n            target = Object.getPrototypeOf(target);\n        }\n    }\n\n    return undefined;\n}\n"],"names":["SPACES","CAMELS","kebabCase","string","matches","trim","exec","replace","lastIndex","toLowerCase","PROPERTY_REFLECTOR_ERROR","propertyReflector","Error","PROPERTY_NOTIFIER_ERROR","propertyNotifier","CustomElement","HTMLElement","[object Object]","super","this","Promise","resolve","Map","_renderRoot","createRenderRoot","console","log","constructor","name","observedAttributes","isConnected","_isConnected","shadow","attachShadow","mode","_listen","requestUpdate","_unlisten","attribute","oldValue","newValue","property","html","render","template","renderCallback","changedProperties","forEach","propertyKey","propertyDeclaration","_getPropertyDeclaration","reflect","call","error","toString","_reflect","_notifyingProperties","notify","_notify","executor","previousChanges","_changedProperties","has","get","set","eventName","dispatchEvent","CustomEvent","composed","detail","previous","current","attributeName","attributeValue","toAttribute","removeAttribute","setAttribute","Object","entries","listenerDeclarations","listener","declaration","instanceDeclaration","event","options","bind","target","addEventListener","_listenerDeclarations","push","removeEventListener","propertyDeclarations","observe","_updateRequest","hasChanged","_hasRequestedUpdate","_enqueueUpdate","requestAnimationFrame","update","previousRequest","res","result","_performUpdate","DEFAULT_CUSTOM_ELEMENT_DECLARATION","selector","define","customElement","window","customElements","DEFAULT_PROPERTY_DECLARATION","value","fromAttribute","descriptor","getPropertyDescriptor","hiddenKey","Symbol","defineProperty","configurable","enumerable","prototype","hasOwnProperty","getOwnPropertyDescriptor","getPrototypeOf"],"mappings":"oGACA,MAAMA,OAAS,aACTC,OAAS,yBAuCCC,UAAWC,GAEvB,IAAIC,EAEJ,GAAID,EAAQ,CAIR,IAFAA,EAASA,EAAOE,OAERD,EAAUJ,OAAOM,KAAKH,IAE1BA,EAASA,EAAOI,QAAQH,EAAQ,GAAI,IAAMA,EAAQ,IAElDJ,OAAOQ,UAAY,EAGvB,KAAQJ,EAAUH,OAAOK,KAAKH,IAE1BA,EAASA,EAAOI,QAAQH,EAAQ,GAAIA,EAAQ,GAAG,GAAK,IAAMA,EAAQ,IAElEH,OAAOO,UAAY,EAI3B,OAAOL,EAASA,EAAOM,cAAgBN,EC3D3C,MAAMO,yBAA4BC,GAA8B,IAAIC,4CAA6CD,MAC3GE,wBAA2BC,GAA6B,IAAIF,2CAA4CE,YA+BjGC,sBAAsBC,YAoC/BC,cAEIC,QArBMC,oBAAmCC,QAAQC,SAAQ,GAEnDF,wBAAuC,IAAIG,IAE3CH,0BAAyC,IAAIG,IAE7CH,2BAAuD,GAEvDA,mBAAe,EAEfA,0BAAsB,EAEtBA,oBAAgB,EAWtBA,KAAKI,YAAcJ,KAAKK,mBAExBC,QAAQC,IAAI,kBAAmBP,KAAKQ,YAAYC,MAhCpDC,gCAEI,MAAO,GAmBXC,kBAEI,OAAOX,KAAKY,aAYhBd,mBAEI,OAAQE,KAAKQ,YAAkCK,OAC3Cb,KAAKc,aAAa,CAAEC,KAAM,SAC1Bf,KAGRF,mBAGAA,oBAEIQ,QAAQC,IAAI,gBAAiBP,KAAKQ,YAAYC,MAE9CT,KAAKgB,UAELhB,KAAKiB,gBAGTnB,uBAEIQ,QAAQC,IAAI,mBAAoBP,KAAKQ,YAAYC,MAEjDT,KAAKkB,YAGTpB,yBAA0BqB,EAAmBC,EAAeC,IAG5DvB,wBAAyBwB,EAAkBF,EAAeC,IAG1DvB,WAEI,OAAOyB,eAGXzB,SAEIQ,QAAQC,IAAI,eAAgBP,KAAKQ,YAAYC,MAE7Ce,eAAOxB,KAAKyB,WAAYzB,KAAKI,aAE7BJ,KAAK0B,iBAGT5B,iBAEIQ,QAAQC,IAAI,eAAgBP,KAAKQ,YAAYC,MAGjDX,OAAQ6B,GAEJrB,QAAQC,IAAI,eAAgBoB,GAE5B3B,KAAKwB,SAELG,EAAkBC,QAAQ,CAACR,EAAeS,KAGtC,MAAMC,EAAsB9B,KAAK+B,wBAAwBF,GACnDR,EAAWrB,KAAK6B,GAGtB,GAAIC,EAAoBE,QAEpB,GAA2C,mBAAhCF,EAAoBE,QAE3B,IACIF,EAAoBE,QAAQC,KAAKjC,KAAM6B,EAAaT,EAAUC,GAChE,MAAOa,GACL,MAAM3C,yBAAyBuC,EAAoBE,QAAQG,iBAG5D,GAA2C,iBAAhCL,EAAoBE,QAElC,IACKhC,KAAK8B,EAAoBE,SAAwDH,EAAaT,EAAUC,GAC3G,MAAOa,GACL,MAAM3C,yBAAyBuC,EAAoBE,cAKvDhC,KAAKoC,SAASP,EAAaT,EAAUC,KAKjDrB,KAAKqC,qBAAqBT,QAAQ,CAACR,EAAUS,KAEzC,MAAMC,EAAsB9B,KAAK+B,wBAAwBF,GACnDR,EAAWrB,KAAK6B,GAEtB,GAAIC,EAAoBQ,OAEpB,GAA0C,mBAA/BR,EAAoBQ,OAE3B,IACIR,EAAoBQ,OAAOL,KAAKjC,KAAM6B,EAAaT,EAAUC,GAC/D,MAAOa,GACL,MAAMxC,wBAAwBoC,EAAoBQ,OAAOH,iBAG1D,GAA0C,iBAA/BL,EAAoBQ,OAElC,IACKtC,KAAK8B,EAAoBQ,QAAsDT,EAAaT,EAAUC,GACzG,MAAOa,GACL,MAAMxC,wBAAwBoC,EAAoBQ,aAKtDtC,KAAKuC,QAAQV,EAAaT,EAAUC,KAmCpDvB,cAAe0C,GAGX,MAAMC,EAAkB,IAAItC,IAAIH,KAAK0C,oBAGrCF,IAGA,IAAK,MAAOX,EAAaT,KAAapB,KAAK0C,mBAElCD,EAAgBE,IAAId,IAAgBY,EAAgBG,IAAIf,KAAiBT,GAE1EpB,KAAKqC,qBAAqBQ,IAAIhB,EAAaT,GAY7CtB,QAAS+B,EAAqBT,EAAeC,GAEnD,MAAMyB,KAAgB/D,UAAU8C,aAEhC7B,KAAK+C,cAAc,IAAIC,YAAYF,EAAW,CAC1CG,UAAU,EACVC,OAAQ,CACJ5B,SAAUO,EACVsB,SAAU/B,EACVgC,QAAS/B,MAIjBf,QAAQC,cAAeuC,QAajBhD,SAAU+B,EAAqBT,EAAeC,GAEpD,MAAMS,EAAsB9B,KAAK+B,wBAAwBF,GAGnDwB,EAAgBvB,EAAoBX,WAAapC,UAAU8C,GAE3DyB,EAAiBxB,EAAoByB,YAAalC,GAEjC,OAAnBiC,EAEAtD,KAAKwD,gBAAgBH,GAIrBrD,KAAKyD,aAAaJ,EAAeC,GAU/BxD,UAEN4D,OAAOC,QAAS3D,KAAKQ,YAAkCoD,sBAAsBhC,QAAQ,EAAEiC,EAAUC,MAE7F,MAAMC,EAAmD,CAGrDC,MAAOF,EAAYE,MACnBC,QAASH,EAAYG,QAGrBJ,SAAW7D,KAAK6D,GAAqDK,KAAKlE,MAG1EmE,OAASL,EAAkB,OACQ,mBAAvBA,EAAYK,OAChBL,EAAYK,SACZL,EAAYK,OAChBnE,MAIR+D,EAAoBI,OAAOC,iBAAiBL,EAAoBC,MAAOD,EAAoBF,SAAUE,EAAoBE,SAGzHjE,KAAKqE,sBAAsBC,KAAKP,KAU9BjE,YAENE,KAAKqE,sBAAsBzC,QAASkC,IAEhCA,EAAYK,OAAOI,oBAAoBT,EAAYE,MAAOF,EAAYD,SAAUC,EAAYG,WAIpGnE,cAAe+B,EAAsBT,EAAgBC,GAEjDf,QAAQC,IAAI,sBAAuBP,KAAKQ,YAAYC,MAEpD,MAAMD,EAAcR,KAAKQ,YAEzB,GAAIqB,GAAeA,KAAerB,EAAYgE,qBAAsB,CAEhE,MAAM1C,EAAsBtB,EAAYgE,qBAAqB3C,GAI7D,GADAvB,QAAQC,0BAA2BsB,cAA0BC,EAAoB2C,YAC5E3C,EAAoB2C,QAAS,OAAOzE,KAAK0E,eAG9C,GAAI5C,EAAoB6C,aAAe7C,EAAoB6C,WAAWvD,EAAUC,GAAW,OAAOrB,KAAK0E,eAGvG1E,KAAK0C,mBAAmBG,IAAIhB,EAAaT,GAS7C,OANKpB,KAAK4E,qBAGN5E,KAAK6E,iBAGF7E,KAAK0E,eAGN5E,iBAIN,OAFAQ,QAAQC,IAAI,sBAAuBP,KAAKQ,YAAYC,MAE7C,IAAIR,QAAQC,IAEf4E,sBAAsB,KAElB9E,KAAK+E,OAAO/E,KAAK0C,oBAEjB1C,KAAK0C,mBAAqB,IAAIvC,IAE9BH,KAAKqC,qBAAuB,IAAIlC,IAIhCH,KAAK4E,qBAAsB,EAE3B1E,QAKJJ,uBAIJ,IAAII,EAFJI,QAAQC,IAAI,sBAAuBP,KAAKQ,YAAYC,MAIpD,MAAMuE,EAAkBhF,KAAK0E,eAE7B1E,KAAK4E,qBAAsB,EAE3B5E,KAAK0E,eAAiB,IAAIzE,QAAiBgF,GAAO/E,EAAU+E,SAEtDD,EAEN,MAAME,EAASlF,KAAKmF,uBAEdD,EAENhF,GAAUF,KAAK4E,qBAGX9E,wBAAyB+B,GAE7B,OAAQ7B,KAAKQ,YAAqCgE,qBAAqB3C,IA/XpEjC,mCAA+D,GAE/DA,mCAA+D,SCrC7DwF,mCAA+D,CACxEC,SAAU,GACVxE,QAAQ,EACRyE,QAAQ,GAGCC,cAAgB,CAACtB,EAAoC,MAE9DA,mBAAemB,mCAAuCnB,GAE9CE,IAEJA,EAAOkB,SAAYpB,EAAgB,SAAIA,EAAQoB,SAAWlB,EAAOkB,SACjElB,EAAOtD,OAASoD,EAAQpD,OAEpBoD,EAAQqB,QAERE,OAAOC,eAAeH,OAAOnB,EAAOkB,SAAUlB,KC2B7CuB,6BAAoD,CAC7DjB,SAAS,EACTnC,QAAQ,EACRN,SAAS,EACT2C,WAAY,CAACvD,EAAeC,IAAkBD,IAAaC,IAAaD,GAAaA,GAAYC,GAAaA,GAC9GkC,YAAaoC,GAASA,EAAMxD,WAC5ByD,cAAeD,GAASA,GAQfrE,SAAW,CAA6C2C,EAAqC,KAE/F,CAACE,EAAgBtC,KAEpB,MAAMgE,EAAaC,sBAAsB3B,EAAQtC,GAC3CkE,EAAoC,iBAAhBlE,MAAiCA,IAAiBmE,SACtEpD,EAAMiD,GAAcA,EAAWjD,KAAO,WAAuB,OAAO5C,KAAK+F,IACzElD,EAAMgD,GAAcA,EAAWhD,KAAO,SAAqB8C,GAAc3F,KAAK+F,GAAaJ,GAEjGjC,OAAOuC,eAAe9B,EAAQtC,EAAa,CACvCqE,cAAc,EACdC,YAAY,EACZrG,MACI,OAAO8C,EAAIX,KAAKjC,OAEpBF,IAAK6F,GACDrF,QAAQC,eAAesB,OAAkB8D,GACzC,MAAMvE,EAAWpB,KAAK6B,GACtBgB,EAAIZ,KAAKjC,KAAM2F,GACf3F,KAAKiB,cAAcY,EAAaT,EAAUuE,MAI9BxB,EAAO3D,YAEfgE,qBAAqB3C,oBAAoB6D,6BAAiCzB,IAe9F,SAAS6B,sBAAuB3B,EAAgBtC,GAE5C,GAAIA,KAAesC,EAEf,KAAOA,IAAWT,OAAO0C,WAAW,CAEhC,GAAIjC,EAAOkC,eAAexE,GAEtB,OAAO6B,OAAO4C,yBAAyBnC,EAAQtC,GAGnDsC,EAAST,OAAO6C,eAAepC"}