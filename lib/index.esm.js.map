{"version":3,"file":"index.esm.js","sources":["../src/decorators/attribute-converter.ts","../src/decorators/utils/string-utils.ts","../src/decorators/property-declaration.ts","../src/custom-element.ts","../src/decorators/custom-element-declaration.ts","../src/decorators/custom-element.ts","../src/decorators/listener.ts","../src/decorators/property.ts","../src/decorators/utils/get-property-descriptor.ts"],"sourcesContent":["/**\n * A function that will map an attribute value to a property value\n */\nexport type AttributeMapper<T = any> = (value: string | null) => T | null;\n\n/**\n * A function that will map a property value to an attribute value\n */\nexport type PropertyMapper<T = any> = (value: T | null) => string | null | undefined;\n\n/**\n * An object that holds an {@link AttributeMapper} and a {@link PropertyMapper}\n *\n * @remarks\n * For the most common types, a converter exists which can be referenced in the {@link PropertyDeclaration}.\n *\n * ```typescript\n * import { CustomElement, property, AttributeConverterBoolean } from 'custom-element';\n *\n * export class MyElement extends CustomElement {\n *\n *      @property({\n *          converter: AttributeConverterBoolean\n *      })\n *      myProperty = true;\n * }\n * ```\n */\nexport interface AttributeConverter<T = any> {\n    toAttribute: PropertyMapper<T>;\n    fromAttribute: AttributeMapper<T>;\n}\n\n/**\n * The default attribute converter\n *\n * @remarks\n * This converter is used as the default converter for decorated properties unless a different one\n * is specified. The converter tries to infer the property type when converting to attributes and\n * uses `JSON.parse()` when converting strings from attributes. If `JSON.parse()` throws an error,\n * the converter will use the attribute value as a string.\n */\nexport const AttributeConverterDefault: AttributeConverter = {\n    fromAttribute: (value: string | null) => {\n        // `JSON.parse()` will throw an error for empty strings - we consider it null\n        if (value === null || value === '') {\n            return null;\n        }\n        else\n            try {\n                // `JSON.parse()` will successfully parse `boolean`, `number` and `JSON.stringify`'d values\n                return JSON.parse(value);\n            }\n            catch (error) {\n                // if it throws, it means we're probably dealing with a regular string\n                return value;\n            }\n    },\n    toAttribute: (value: any) => {\n        switch (typeof value) {\n            case 'boolean':\n                return value ? '' : null;\n            case 'object':\n                return (value == null) ? value : JSON.stringify(value);\n            case 'undefined':\n                return value;\n            case 'string':\n                return value;\n            default: // number, bigint, symbol, function\n                return value.toString();\n        }\n    }\n};\n\nexport const AttributeConverterBoolean: AttributeConverter<boolean> = {\n    fromAttribute: (value: string | null) => (value !== null),\n    toAttribute: (value: boolean | null) => value ? '' : null\n}\n\nexport const AttributeConverterString: AttributeConverter<string> = {\n    fromAttribute: (value: string | null) => (value === null) ? null : value,\n    // pass through null or undefined\n    toAttribute: (value: string | null) => value\n}\n\nexport const AttributeConverterNumber: AttributeConverter<number> = {\n    fromAttribute: (value: string | null) => (value === null) ? null : Number(value),\n    // pass through null or undefined using `value == null`\n    toAttribute: (value: number | null) => (value == null) ? value : value.toString()\n}\n\nexport const AttributeConverterObject: AttributeConverter<object> = {\n    // `JSON.parse()` will throw an error for empty strings - we consider it null\n    fromAttribute: (value: string | null) => (value === null || value === '') ? null : JSON.parse(value),\n    // pass through null or undefined using `value == null`\n    toAttribute: (value: object | null) => (value == null) ? value : JSON.stringify(value)\n}\n\nexport const AttributeConverterArray: AttributeConverter<any[]> = {\n    // `JSON.parse()` will throw an error for empty strings - we consider it null\n    fromAttribute: (value: string | null) => (value === null || value === '') ? null : JSON.parse(value),\n    // pass through null or undefined using `value == null`\n    toAttribute: (value: any[] | null) => (value == null) ? value : JSON.stringify(value)\n};\n\nexport const AttributeConverterDate: AttributeConverter<Date> = {\n    // `new Date()` will return an `Invalid Date` for empty strings - we consider it null\n    fromAttribute: (value: string | null) => (value === null || value === '') ? null : new Date(value),\n    // pass through null or undefined using `value == null`\n    toAttribute: (value: Date | null) => (value == null) ? value : value.toString()\n}\n","const FIRST = /^[^]/;\nconst SPACES = /\\s+([\\S])/g;\nconst CAMELS = /[a-z]([A-Z])/g;\nconst KEBABS = /-([a-z])/g;\n\nexport function capitalize (string: string): string {\n\n    return string ? string.replace(FIRST, string[0].toUpperCase()) : string;\n}\n\nexport function uncapitalize (string: string): string {\n\n    return string ? string.replace(FIRST, string[0].toLowerCase()) : string;\n}\n\nexport function camelCase (string: string): string {\n\n    let matches;\n\n    if (string) {\n\n        string = string.trim();\n\n        while ((matches = SPACES.exec(string))) {\n\n            string = string.replace(matches[0], matches[1].toUpperCase());\n\n            SPACES.lastIndex = 0;\n        }\n\n        while ((matches = KEBABS.exec(string))) {\n\n            string = string.replace(matches[0], matches[1].toUpperCase());\n\n            KEBABS.lastIndex = 0;\n        }\n    }\n\n    return uncapitalize(string);\n}\n\nexport function kebabCase (string: string): string {\n\n    let matches;\n\n    if (string) {\n\n        string = string.trim();\n\n        while ((matches = SPACES.exec(string))) {\n\n            string = string.replace(matches[0], '-' + matches[1]);\n\n            SPACES.lastIndex = 0;\n        }\n\n        while ((matches = CAMELS.exec(string))) {\n\n            string = string.replace(matches[0], matches[0][0] + '-' + matches[1]);\n\n            CAMELS.lastIndex = 0;\n        }\n    }\n\n    return string ? string.toLowerCase() : string;\n}\n","import { CustomElement } from '../custom-element';\nimport { AttributeConverter, AttributeConverterDefault } from './attribute-converter';\nimport { kebabCase } from './utils/string-utils';\n\n/**\n * A function that will reflect an attribute value to a property\n */\nexport type AttributeReflector<Type extends CustomElement = CustomElement> = (this: Type, attributeName: string, oldValue: string | null, newValue: string | null) => void;\n\n/**\n * A function that will reflect a property value to an attribute\n */\nexport type PropertyReflector<Type extends CustomElement = CustomElement> = (this: Type, propertyKey: PropertyKey, oldValue: any, newValue: any) => void;\n\n/**\n * A function that will dispatch a custom event for a property change\n */\nexport type PropertyNotifier<Type extends CustomElement = CustomElement> = (this: Type, propertyKey: PropertyKey, oldValue: any, newValue: any) => void;\n\n/**\n * A function that will return `true` if the `oldValue` and the `newValue` of a property are different, `false` otherwise\n */\nexport type PropertyChangeDetector = (oldValue: any, newValue: any) => boolean;\n\n/**\n * A type guard for {@link AttributeReflector}\n *\n * @param reflector A reflector to test\n */\nexport function isAttributeReflector (reflector: any): reflector is AttributeReflector {\n\n    return typeof reflector === 'function';\n}\n\n/**\n * A type guard for {@link PropertyReflector}\n *\n * @param reflector A reflector to test\n */\nexport function isPropertyReflector (reflector: any): reflector is PropertyReflector {\n\n    return typeof reflector === 'function';\n}\n\n/**\n * A type guard for {@link PropertyNotifier}\n *\n * @param notifier A notifier to test\n */\nexport function isPropertyNotifier (notifier: any): notifier is PropertyNotifier {\n\n    return typeof notifier === 'function';\n}\n\n/**\n * A type guard for {@link PropertyChangeDetector}\n *\n * @param detector A detector to test\n */\nexport function isPropertyChangeDetector (detector: any): detector is PropertyChangeDetector {\n\n    return typeof detector === 'function';\n}\n\n/**\n * A type guard for {@link PropertyKey}\n *\n * @param key A property key to test\n */\nexport function isPropertyKey (key: any): key is PropertyKey {\n\n    return typeof key === 'string' || typeof key === 'number' || typeof key === 'symbol';\n}\n\n/**\n * Encodes a string for use as html attribute removing invalid attribute characters\n *\n * @param value A string to encode for use as html attribute\n * @returns     An encoded string usable as html attribute\n */\nexport function encodeAttribute (value: string): string {\n\n    return kebabCase(value.replace(/\\W+/g, '-').replace(/\\-$/, ''));\n}\n\n/**\n * A helper function to create an attribute name from a property key\n *\n * @remarks\n * Numeric property indexes or symbols can contain invalid characters for attribute names. This method\n * sanitizes those characters and replaces sequences of invalid characters with a dash.\n * Attribute names are not allowed to start with numbers either and are prefixed with 'attr-'.\n *\n * N.B.: When using custom symbols as property keys, use unique descriptions for the symbols to avoid\n * clashing attribute names.\n *\n * ```typescript\n * const a = Symbol();\n * const b = Symbol();\n *\n * a !== b; // true\n *\n * createAttributeName(a) !== createAttributeName(b); // false --> 'attr-symbol' === 'attr-symbol'\n *\n * const c = Symbol('c');\n * const d = Symbol('d');\n *\n * c !== d; // true\n *\n * createAttributeName(c) !== createAttributeName(d); // true --> 'attr-symbol-c' === 'attr-symbol-d'\n * ```\n *\n * @param propertyKey   A property key to convert to an attribute name\n * @returns             The generated attribute name\n */\nexport function createAttributeName (propertyKey: PropertyKey): string {\n\n    if (typeof propertyKey === 'string') {\n\n        return kebabCase(propertyKey);\n\n    } else {\n\n        // TODO: this could create multiple identical attribute names, if symbols don't have unique description\n        return `attr-${ encodeAttribute(String(propertyKey)) }`;\n    }\n}\n\n/**\n * A helper function to create an event name from a property key\n *\n * @remarks\n * Event names don't have the same restrictions as attribute names when it comes to invalid\n * characters. However, for consistency's sake, we apply the same rules for event names as\n * for attribute names.\n *\n * @param propertyKey   A property key to convert to an attribute name\n * @param prefix        An optional prefix, e.g.: 'on'\n * @param suffix        An optional suffix, e.g.: 'changed'\n * @returns             The generated event name\n */\nexport function createEventName (propertyKey: PropertyKey, prefix?: string, suffix?: string): string {\n\n    let propertyString = '';\n\n    if (typeof propertyKey === 'string') {\n\n        propertyString = kebabCase(propertyKey);\n\n    } else {\n\n        // TODO: this could create multiple identical event names, if symbols don't have unique description\n        propertyString = encodeAttribute(String(propertyKey));\n    }\n\n    return `${ prefix ? `${ kebabCase(prefix) }-` : '' }${ propertyString }${ suffix ? `-${ kebabCase(suffix) }` : '' }`;\n}\n\n/**\n * A {@link CustomElement} property declaration\n */\nexport interface PropertyDeclaration<Type extends CustomElement = CustomElement> {\n    /**\n     * Does property have an associated attribute?\n     *\n     * @remarks\n     * Possible values:\n     * * `false`: No attribute will be associated with this property\n     * * `true`: The attribute name will be inferred by camel-casing the property name\n     * * `string`: Use the provided string as the associated attribute name\n     *\n     * Default value: `true`\n     */\n    attribute: boolean | string;\n\n    /**\n     * Customize the conversion of values between property and associated attribute\n     *\n     * @remarks\n     * Converters are only used when {@link reflectProperty} and/or {@link reflectAttribute} are set to true.\n     * If custom reflectors are used, they have to take care or converting the property/attribute values.\n     *\n     * Default value: {@link AttributeConverterDefault}\n     */\n    converter: AttributeConverter;\n\n    /**\n     * Should the associated attribute's value be automatically reflected to the property?\n     *\n     * @remarks\n     * Possible values:\n     * * `false`: The attribute value will not be reflected to the property automatically\n     * * `true`: Any attribute change will be reflected automatically to the property using the default attribute reflector\n     * * `PropertyKey`: A method on the custom element with that property key will be invoked to handle the attribute reflection\n     * * `Function`: The provided function will be invoked with its `this` context bound to the custom element instance\n     *\n     * Default value: `true`\n     */\n    reflectAttribute: boolean | keyof Type | AttributeReflector<Type>;\n\n    /**\n     * Should the property value be automatically reflected to the associated attribute?\n     *\n     * @remarks\n     * Possible values:\n     * * `false`: The property value will not be reflected to the associated attribute automatically\n     * * `true`: Any property change will be reflected automatically to the associated attribute using the default property reflector\n     * * `PropertyKey`: A method on the custom element with that property key will be invoked to handle the property reflection\n     * * `Function`: The provided function will be invoked with its `this` context bound to the custom element instance\n     *\n     * Default value: `true`\n     */\n    reflectProperty: boolean | keyof Type | PropertyReflector<Type>;\n\n    /**\n     * Should a property value change raise a custom event?\n     *\n     * @remarks\n     * Possible values:\n     * * `false`: Don't create a custom event for this property\n     * * `true`: Create custom events for this property automatically\n     * * `PropertyKey`: Use the method with this property key on the custom element to create custom events\n     * * `Function`: Use the the provided function to create custom events (`this` context will be the custom element instance)\n     *\n     * Default value: `true`\n     */\n    notify: boolean | keyof Type | PropertyNotifier<Type>;\n\n    /**\n     * Configure how changes of this property should be monitored\n     *\n     * @remarks\n     * By default a decorated property will be observed for changes (through a custom setter for the property).\n     * Any `set`-operation of this property will therefore request an update of the custom element and initiate\n     * a render as well as reflection and notification.\n     *\n     * Possible values:\n     * * `false`: Don't observe changes of this property (this will bypass render, reflection and notification)\n     * * `true`: Observe changes of this property using the {@link DEFAULT_PROPERTY_CHANGE_DETECTOR}\n     * * `Function`: Use the provided method to check if property value has changed\n     *\n     * Default value: `true` (uses {@link DEFAULT_PROPERTY_CHANGE_DETECTOR} internally)\n     */\n    observe: boolean | PropertyChangeDetector;\n}\n\n/**\n * The default property change detector\n *\n * @param oldValue  The old property value\n * @param newValue  The new property value\n * @returns         A boolean indicating if the property value changed\n */\nexport const DEFAULT_PROPERTY_CHANGE_DETECTOR: PropertyChangeDetector = (oldValue: any, newValue: any) => {\n    // in case `oldValue` and `newValue` are `NaN`, `(NaN !== NaN)` returns `true`,\n    // but `(NaN === NaN || NaN === NaN)` returns `false`\n    return oldValue !== newValue && (oldValue === oldValue || newValue === newValue);\n};\n\n// TODO: maybe provide flat array/object change detector? date change detector?\n\n/**\n * The default {@link CustomElement} property declaration\n */\nexport const DEFAULT_PROPERTY_DECLARATION: PropertyDeclaration = {\n    attribute: true,\n    converter: AttributeConverterDefault,\n    reflectAttribute: true,\n    reflectProperty: true,\n    notify: true,\n    observe: DEFAULT_PROPERTY_CHANGE_DETECTOR,\n};\n","import { render, TemplateResult } from 'lit-html';\nimport { ListenerDeclaration } from './decorators/listener';\nimport { AttributeReflector, createEventName, isAttributeReflector, isPropertyChangeDetector, isPropertyKey, isPropertyNotifier, isPropertyReflector, PropertyDeclaration, PropertyNotifier, PropertyReflector } from \"./decorators/property-declaration\";\n\nconst ATTRIBUTE_REFLECTOR_ERROR = (attributeReflector: PropertyKey | Function) => new Error(`Error executing attribute reflector ${ String(attributeReflector) }.`);\nconst PROPERTY_REFLECTOR_ERROR = (propertyReflector: PropertyKey | Function) => new Error(`Error executing property reflector ${ String(propertyReflector) }.`);\nconst PROPERTY_NOTIFIER_ERROR = (propertyNotifier: PropertyKey | Function) => new Error(`Error executing property notifier ${ String(propertyNotifier) }.`);\nconst CHANGE_DETECTOR_ERROR = (changeDetector: PropertyKey | Function) => new Error(`Error executing property change detector ${ String(changeDetector) }.`);\n\n/**\n * Extends the static {@link ListenerDeclaration} to include the bound listener\n * for a custom element instance.\n */\ninterface InstanceListenerDeclaration extends ListenerDeclaration {\n\n    /**\n     * The bound listener will be stored here, so it can be removed it later\n     */\n    listener: EventListener;\n\n    /**\n     * The event target will always be resolved to an actual {@link EventTarget}\n     */\n    target: EventTarget;\n}\n\n/**\n * A type for property changes, as used in ${@link CustomElement.updateCallback}\n */\nexport type Changes = Map<PropertyKey, any>;\n\n/**\n * The custom element base class\n */\nexport abstract class CustomElement extends HTMLElement {\n\n    /**\n     * The custom element's cached stylesheet instance\n     *\n     * @private\n     * @internal\n     */\n    protected static _styleSheet: CSSStyleSheet | undefined;\n\n    /**\n     * The custom element's stylesheet object\n     *\n     * @remarks\n     * When constructable stylesheets are available, this getter will create a {@link CSSStyleSheet}\n     * instance and cache it for use with each instance of the custom element.\n     *\n     * @private\n     * @internal\n     */\n    protected static get styleSheet (): CSSStyleSheet | undefined {\n\n        if (!this._styleSheet) {\n\n            try {\n\n                // create a style sheet and cache it in the constructor\n                // this will work once constructable stylesheets arrive\n                // https://wicg.github.io/construct-stylesheets/\n                this._styleSheet = new CSSStyleSheet();\n                this._styleSheet.replaceSync(this.styles.join('\\n'));\n\n            } catch (error) { }\n        }\n\n        return this._styleSheet;\n    }\n\n    /**\n     * The custom element's selector\n     *\n     * @remarks\n     * Will be overridden by the {@link customElement} decorator's `selector` option, if provided.\n     * Otherwise the decorator will use this property to define the custom element.\n     */\n    static selector: string;\n\n    /**\n     * Use Shadow DOM\n     *\n     * @remarks\n     * Will be set by the {@link customElement} decorator's `shadow` option (defaults to `true`).\n     */\n    static shadow: boolean;\n\n    /**\n     * A map of attribute names and their respective property keys\n     *\n     * @internal\n     * @private\n     */\n    static attributes: Map<string, PropertyKey> = new Map();\n\n    /**\n     * A map of property keys and their respective property declarations\n     *\n     * @internal\n     * @private\n     */\n    static properties: Map<PropertyKey, PropertyDeclaration> = new Map();\n\n    /**\n     * A map of property keys and their respective listener declarations\n     *\n     * @internal\n     * @private\n     */\n    static listeners: Map<PropertyKey, ListenerDeclaration> = new Map();\n\n    // TODO: create tests for style inheritance\n    /**\n     * The custom element's styles\n     *\n     * @remarks\n     * Can be set through the {@link customElement} decorator's `styles` option (defaults to `undefined`).\n     * Styles set in the {@link customElement} decorator will be merged with the class's static property.\n     * This allows to inherit styles from a parent component and add additional styles on the child component.\n     * In order to inherit styles from a parent component, an explicit super call has to be included. By\n     * default no styles are inherited.\n     *\n     * ```typescript\n     * @customElement({\n     *      selector: 'my-element'\n     * })\n     * class MyElement extends MyBaseElement {\n     *\n     *      static get styles (): string[] {\n     *\n     *          return [\n     *              ...super.styles,\n     *              ':host { background-color: green; }'\n     *          ];\n     *      }\n     * }\n     * ```\n     */\n    static get styles (): string[] {\n\n        return [];\n    }\n\n    /**\n     * The custom element's template\n     *\n     * @remarks\n     * Can be set though the {@link customElement} decorator's `template` option (defaults to `undefined`).\n     * If set in the {@link customElement} decorator, it will have precedence over the class's static property.\n     *\n     * @param element   The custom element instance\n     * @param helpers   Any additional properties which should exist in the template scope\n     */\n    static template?: (element: any, ...helpers: any[]) => TemplateResult | void;\n\n    /**\n     * Override to specify attributes which should be observed, but don't have an associated property\n     *\n     * @remark\n     * For properties which are decorated with the {@link property} decorator, an observed attribute\n     * is automatically created and does not need to be specified here. Fot attributes that don't\n     * have an associated property, return the attribute names in this getter. Changes to these\n     * attributes can be handled in the {@link attributeChangedCallback} method.\n     *\n     * When extending custom elements, make sure to return the super class's observedAttributes\n     * if you override this getter (except if you don't want to inherit observed attributes):\n     *\n     * ```typescript\n     * @customElement({\n     *      selector: 'my-element'\n     * })\n     * class MyElement extends MyBaseElement {\n     *\n     *      static get observedAttributes (): string[] {\n     *\n     *          return [...super.observedAttributes, 'my-additional-attribute'];\n     *      }\n     * }\n     * ```\n     */\n    static get observedAttributes (): string[] {\n\n        return [];\n    }\n\n    /**\n     * @internal\n     * @private\n     */\n    protected _renderRoot: Element | DocumentFragment;\n\n    /**\n     * @internal\n     * @private\n     */\n    protected _updateRequest: Promise<boolean> = Promise.resolve(true);\n\n    /**\n     * @internal\n     * @private\n     */\n    protected _changedProperties: Map<PropertyKey, any> = new Map();\n\n    /**\n     * @internal\n     * @private\n     */\n    protected _reflectingProperties: Map<PropertyKey, any> = new Map();\n\n    /**\n     * @internal\n     * @private\n     */\n    protected _notifyingProperties: Map<PropertyKey, any> = new Map();\n\n    /**\n     * @internal\n     * @private\n     */\n    protected _listenerDeclarations: InstanceListenerDeclaration[] = [];\n\n    /**\n     * @internal\n     * @private\n     */\n    protected _hasUpdated = false;\n\n    /**\n     * @internal\n     * @private\n     */\n    protected _hasRequestedUpdate = false;\n\n    /**\n     * @internal\n     * @private\n     */\n    protected _isReflecting = false;\n\n    /**\n     * The custom element constructor\n     */\n    constructor () {\n\n        super();\n\n        this._renderRoot = this.createRenderRoot();\n    }\n\n    /**\n     * Invoked each time the custom element is moved to a new document\n     *\n     * @remarks\n     * https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements#Using_the_lifecycle_callbacks\n     *\n     * N.B.: When overriding this callback, make sure to include a super-call.\n     */\n    adoptedCallback () {\n\n        this._notifyLifecycle('adopted');\n    }\n\n    /**\n     * Invoked each time the custom element is appended into a document-connected element\n     *\n     * @remarks\n     * https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements#Using_the_lifecycle_callbacks\n     *\n     * N.B.: When overriding this callback, make sure to include a super-call.\n     */\n    connectedCallback () {\n\n        this.requestUpdate();\n\n        this._notifyLifecycle('connected');\n    }\n\n    /**\n     * Invoked each time the custom element is disconnected from the document's DOM\n     *\n     * @remarks\n     * https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements#Using_the_lifecycle_callbacks\n     *\n     * N.B.: When overriding this callback, make sure to include a super-call.\n     */\n    disconnectedCallback () {\n\n        this._unlisten();\n\n        this._notifyLifecycle('disconnected');\n\n        this._hasUpdated = false;\n    }\n\n    /**\n     * Invoked each time one of the custom element's attributes is added, removed, or changed\n     *\n     * @remarks\n     * Which attributes to notice change for is specified in {@link observedAttributes}.\n     * https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements#Using_the_lifecycle_callbacks\n     *\n     * For decorated properties with an associated attribute, this is handled automatically.\n     *\n     * This method can be overridden to customize the handling of attribute changes. When overriding\n     * this method, a super-call should be included, to ensure attribute changes for decorated properties\n     * are processed correctly.\n     *\n     * ```typescript\n     * @customElement({\n     *      selector: 'my-element'\n     * })\n     * class MyElement extends CustomElement {\n     *\n     *      attributeChangedCallback (attribute: string, oldValue: any, newValue: any) {\n     *\n     *          super.attributeChangedCallback(attribute, oldValue, newValue);\n     *\n     *          // do custom handling...\n     *      }\n     * }\n     * ```\n     *\n     * @param attribute The name of the changed attribute\n     * @param oldValue  The old value of the attribute\n     * @param newValue  The new value of the attribute\n     */\n    attributeChangedCallback (attribute: string, oldValue: string | null, newValue: string | null) {\n\n        if (this._isReflecting) return;\n\n        if (oldValue !== newValue) this.reflectAttribute(attribute, oldValue, newValue);\n    }\n\n    /**\n     * Invoked each time the custom element updates\n     *\n     * @remarks\n     * The updateCallback is invoked synchronously from the {@link update} method and therefore happens directly after\n     * rendering, property reflection and property change events.\n     *\n     * N.B.: Changes made to properties or attributes inside this callback *won't* cause another update.\n     *\n     * @param changedProperties A map of properties that changed in the update, containg the property key and the old value\n     * @param firstUpdate       A boolean indicating if this was the first update\n     */\n    updateCallback (changedProperties: Changes, firstUpdate: boolean) { }\n\n    /**\n     * Creates the custom element's render root\n     *\n     * @remarks\n     * The render root is where the {@link render} method will attach its DOM output. When using the custom element\n     * with shadow mode, it will be a {@link ShadowRoot}, otherwise it will be the custom element itself.\n     *\n     * @internal\n     * @private\n     */\n    protected createRenderRoot (): Element | DocumentFragment {\n\n        return (this.constructor as typeof CustomElement).shadow ?\n            this.attachShadow({ mode: 'open' }) :\n            this;\n    }\n\n    /**\n     * Adds the custom element's styles to its {@link _renderRoot}\n     *\n     * @remarks\n     * If constructable stylesheets are available, the custom element's {@link CSSStyleSheet} instance will be adopted\n     * by the {@link ShadowRoot}. If not, a style element is created and attached to the {@link ShadowRoot}. If the\n     * custom element is not using shadow mode, a script tag will be appended to the document's `<head>`. For multiple\n     * instances of the same custom element only one stylesheet will be added to the document.\n     *\n     * @internal\n     * @private\n     */\n    protected adoptStyles () {\n\n        const constructor = this.constructor as typeof CustomElement;\n        const styleSheet = constructor.styleSheet;\n        const styles = constructor.styles;\n\n        if (styleSheet) {\n\n            // TODO: test this part once we have constructable stylesheets (Chrome 73)\n            if (!constructor.shadow) {\n\n                if ((document as DocumentOrShadowRoot).adoptedStyleSheets.includes(styleSheet)) return;\n\n                (document as DocumentOrShadowRoot).adoptedStyleSheets = [\n                    ...(document as DocumentOrShadowRoot).adoptedStyleSheets,\n                    styleSheet\n                ];\n\n            } else {\n\n                // this will work once constructable stylesheets arrive\n                // https://wicg.github.io/construct-stylesheets/\n                (this._renderRoot as ShadowRoot).adoptedStyleSheets = [styleSheet];\n            }\n\n        } else if (styles.length) {\n\n            // TODO: test we don't duplicate stylesheets for non-shadow elements\n            const styleAlreadyAdded = constructor.shadow\n                ? false\n                : Array.from(document.styleSheets).find(style => style.title === constructor.selector) && true || false;\n\n            if (styleAlreadyAdded) return;\n\n            const style = document.createElement('style');\n            style.title = constructor.selector;\n            style.textContent = styles.join('\\n');\n\n            if (constructor.shadow) {\n\n                this._renderRoot.appendChild(style);\n\n            } else {\n\n                document.head.appendChild(style);\n            }\n        }\n    }\n\n    /**\n     * Renders the custom element's template to its {@link _renderRoot}\n     *\n     * @remarks\n     * Uses lit-html's {@link lit-html#render} method to render a {@link lit-html#TemplateResult} to the\n     * custom element's render root. The custom element instance will be passed to the static template method\n     * automatically. To make additional properties available to the template method, you can pass them to the\n     * render method.\n     *\n     * ```typescript\n     * const dateFormatter = (date: Date) => { // return some date transformation...\n     * };\n     *\n     * @customElement({\n     *      selector: 'my-element',\n     *      template: (element, formatDate) => html`<span>Last updated: ${ formatDate(element.lastUpdated) }</span>`\n     * })\n     * class MyElement extends CustomElement {\n     *\n     *      @property()\n     *      lastUpdated: Date;\n     *\n     *      render () {\n     *          // make the date formatter available in the template by passing it to render()\n     *          super.render(dateFormatter);\n     *      }\n     * }\n     * ```\n     *\n     * @param helpers   Any additional objects which should be available in the template scope\n     */\n    protected render (...helpers: any[]) {\n\n        const constructor = this.constructor as typeof CustomElement;\n\n        const template = constructor.template && constructor.template(this, ...helpers);\n\n        if (template) render(template, this._renderRoot, { eventContext: this });\n    }\n\n    /**\n     * Dispatch a custom event\n     *\n     * @remarks\n     * https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent\n     *\n     * @param eventName An event name\n     * @param eventInit A {@link CustomEventInit} dictionary\n     */\n    protected notify (eventName: string, eventInit?: CustomEventInit) {\n\n        this.dispatchEvent(new CustomEvent(eventName, eventInit));\n    }\n\n    /**\n     * Watch property changes occurring in the executor and raise custom events\n     *\n     * @remarks\n     * Property changes should trigger custom events when they are caused by internal state changes,\n     * but not if they are caused by a consumer of the custom element API directly, e.g.:\n     *\n     * ```typescript\n     * document.querySelector('my-custom-element').customProperty = true;\n     * ```.\n     *\n     * This means, we cannot automate this process through property setters, as we can't be sure who\n     * invoked the setter - internal calls or external calls.\n     *\n     * One option is to manually raise the event, which can become tedious and forces us to use string-\n     * based event names or property names, which are difficult to refactor, e.g.:\n     *\n     * ```typescript\n     * this.customProperty = true;\n     * // if we refactor the property name, we can easily miss the notify call\n     * this.notify('customProperty');\n     * ```\n     *\n     * A more convenient way is to execute the internal changes in a wrapper which can detect the changed\n     * properties and will automatically raise the required events. This eliminates the need to manually\n     * raise events and refactoring does no longer affect the process.\n     *\n     * ```typescript\n     * this.watch(() => {\n     *\n     *      this.customProperty = true;\n     *      // we can add more property modifications to notify in here\n     * });\n     * ```\n     *\n     * @param executor A function that performs the changes which should be notified\n     */\n    protected watch (executor: () => void) {\n\n        // back up current changed properties\n        const previousChanges = new Map(this._changedProperties);\n\n        // execute the changes\n        executor();\n\n        // add all new or updated changed properties to the notifying properties\n        for (const [propertyKey, oldValue] of this._changedProperties) {\n\n            if (!previousChanges.has(propertyKey) || this.hasChanged(propertyKey, previousChanges.get(propertyKey), oldValue)) {\n\n                this._notifyingProperties.set(propertyKey, oldValue);\n            }\n        }\n    }\n\n    /**\n     * Request an update of the custom element\n     *\n     * @remarks\n     * This method is called automatically when the value of a decorated property or its associated\n     * attribute changes. If you need the custom element to update based on a state change that is\n     * not covered by a decorated property, call this method without any arguments.\n     *\n     * @param propertyKey   The name of the changed property that requests the update\n     * @param oldValue      The old property value\n     * @param newValue      the new property value\n     * @returns             A Promise which is resolved when the update is completed\n     */\n    protected requestUpdate (propertyKey?: PropertyKey, oldValue?: any, newValue?: any): Promise<boolean> {\n\n        if (propertyKey) {\n\n            // if the {@link PropertyDeclaration}'s observe option is `false`, {@link hasChanged}\n            // will return `false` and no update will be requested\n            if (!this.hasChanged(propertyKey, oldValue, newValue)) return this._updateRequest;\n\n            // store changed property for batch processing\n            this._changedProperties.set(propertyKey, oldValue);\n\n            // if we are in reflecting state, an attribute is reflecting to this property and we\n            // can skip reflecting the property back to the attribute\n            // property changes need to be tracked however and {@link render} must be called after\n            // the attribute change is reflected to this property\n            if (!this._isReflecting) this._reflectingProperties.set(propertyKey, oldValue);\n        }\n\n        if (!this._hasRequestedUpdate) {\n\n            // enqueue update request if none was enqueued already\n            this._enqueueUpdate();\n        }\n\n        return this._updateRequest;\n    }\n\n    /**\n     * Updates the custom element after an update was requested with {@link requestUpdate}\n     *\n     * @remarks\n     * This method renders the template, reflects changed properties to attributes and\n     * dispatches change events for properties which are marked for notification.\n     */\n    protected update () {\n\n        this.render();\n\n        // reflect all properties marked for reflection\n        this._reflectingProperties.forEach((oldValue: any, propertyKey: PropertyKey) => {\n\n            this.reflectProperty(propertyKey, oldValue, this[propertyKey as keyof CustomElement]);\n        });\n\n        // notify all properties marked for notification\n        this._notifyingProperties.forEach((oldValue, propertyKey) => {\n\n            this.notifyProperty(propertyKey, oldValue, this[propertyKey as keyof CustomElement]);\n        });\n    }\n\n    /**\n     * Gets the {@link PropertyDeclaration} for a decorated property\n     *\n     * @param propertyKey The property key for which to retrieve the declaration\n     */\n    protected getPropertyDeclaration (propertyKey: PropertyKey): PropertyDeclaration | undefined {\n\n        return (this.constructor as typeof CustomElement).properties.get(propertyKey);\n    }\n\n    /**\n     * Check if a property changed\n     *\n     * @remarks\n     * This method resolves the {@link PropertyChangeDetector} for the property and returns its result.\n     * If none is defined (the property declaration's `observe` option is `false`) it returns false.\n     * It catches any error in custom {@link PropertyChangeDetector}s and throws a more helpful one.\n     *\n     * @param propertyKey   The key of the property to check\n     * @param oldValue      The old property value\n     * @param newValue      The new property value\n     * @returns             `true` if the property changed, `false` otherwise\n     */\n    protected hasChanged (propertyKey: PropertyKey, oldValue: any, newValue: any): boolean {\n\n        const propertyDeclaration = this.getPropertyDeclaration(propertyKey);\n\n        // observe is either `false` or a {@link PropertyChangeDetector}\n        if (propertyDeclaration && isPropertyChangeDetector(propertyDeclaration.observe)) {\n\n            try {\n                return propertyDeclaration.observe.call(null, oldValue, newValue);\n\n            } catch (error) {\n\n                throw CHANGE_DETECTOR_ERROR(propertyDeclaration.observe);\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Reflect an attribute value to its associated property\n     *\n     * @remarks\n     * This method checks, if any custom {@link AttributeReflector} has been defined for the\n     * associated property and invokes the appropriate reflector. If not, it will use the default\n     * reflector {@link _reflectAttribute}.\n     *\n     * It catches any error in custom {@link AttributeReflector}s and throws a more helpful one.\n     *\n     * @param attributeName The propert key of the property to reflect\n     * @param oldValue      The old property value\n     * @param newValue      The new property value\n     */\n    protected reflectAttribute (attributeName: string, oldValue: string | null, newValue: string | null) {\n\n        const constructor = this.constructor as typeof CustomElement;\n\n        const propertyKey = constructor.attributes.get(attributeName);\n\n        // ignore user-defined observed attributes\n        // TODO: test this and remove the log\n        if (!propertyKey) {\n\n            console.log(`observed attribute \"${ attributeName }\" not found... ignoring...`);\n\n            return;\n        }\n\n        const propertyDeclaration = this.getPropertyDeclaration(propertyKey)!;\n\n        // don't reflect if {@link PropertyDeclaration.reflectAttribute} is false\n        if (propertyDeclaration.reflectAttribute) {\n\n            this._isReflecting = true;\n\n            if (isAttributeReflector(propertyDeclaration.reflectAttribute)) {\n\n                try {\n                    propertyDeclaration.reflectAttribute.call(this, attributeName, oldValue, newValue);\n\n                } catch (error) {\n\n                    throw ATTRIBUTE_REFLECTOR_ERROR(propertyDeclaration.reflectAttribute);\n                }\n\n            } else if (isPropertyKey(propertyDeclaration.reflectAttribute)) {\n\n                try {\n                    (this[propertyDeclaration.reflectAttribute] as AttributeReflector)(attributeName, oldValue, newValue);\n\n                } catch (error) {\n\n                    throw ATTRIBUTE_REFLECTOR_ERROR(propertyDeclaration.reflectAttribute);\n                }\n\n            } else {\n\n                this._reflectAttribute(attributeName, oldValue, newValue);\n            }\n\n            this._isReflecting = false;\n        }\n    }\n\n    /**\n     * Reflect a property value to its associated attribute\n     *\n     * @remarks\n     * This method checks, if any custom {@link PropertyReflector} has been defined for the\n     * property and invokes the appropriate reflector. If not, it will use the default\n     * reflector {@link _reflectProperty}.\n     *\n     * It catches any error in custom {@link PropertyReflector}s and throws a more helpful one.\n     *\n     * @param propertyKey   The propert key of the property to reflect\n     * @param oldValue      The old property value\n     * @param newValue      The new property value\n     */\n    protected reflectProperty (propertyKey: PropertyKey, oldValue: any, newValue: any) {\n\n        const propertyDeclaration = this.getPropertyDeclaration(propertyKey);\n\n        // don't reflect if {@link propertyDeclaration.reflectProperty} is false\n        if (propertyDeclaration && propertyDeclaration.reflectProperty) {\n\n            // attributeChangedCallback is called synchronously, we can catch the state there\n            this._isReflecting = true;\n\n            if (isPropertyReflector(propertyDeclaration.reflectProperty)) {\n\n                try {\n                    propertyDeclaration.reflectProperty.call(this, propertyKey, oldValue, newValue);\n\n                } catch (error) {\n\n                    throw PROPERTY_REFLECTOR_ERROR(propertyDeclaration.reflectProperty);\n                }\n\n            } else if (isPropertyKey(propertyDeclaration.reflectProperty)) {\n\n                try {\n                    (this[propertyDeclaration.reflectProperty] as PropertyReflector)(propertyKey, oldValue, newValue);\n\n                } catch (error) {\n\n                    throw PROPERTY_REFLECTOR_ERROR(propertyDeclaration.reflectProperty);\n                }\n\n            } else {\n\n                this._reflectProperty(propertyKey, oldValue, newValue);\n            }\n\n            this._isReflecting = false;\n        }\n    }\n\n    /**\n     * Raise an event for a property change\n     *\n     * @remarks\n     * This method checks, if any custom {@link PropertyNotifier} has been defined for the\n     * property and invokes the appropriate notifier. If not, it will use the default\n     * notifier {@link _notifyProperty}.\n     *\n     * It catches any error in custom {@link PropertyReflector}s and throws a more helpful one.\n     *\n     * @param propertyKey   The propert key of the property to raise an event for\n     * @param oldValue      The old property value\n     * @param newValue      The new property value\n     */\n    protected notifyProperty (propertyKey: PropertyKey, oldValue: any, newValue: any) {\n\n        const propertyDeclaration = this.getPropertyDeclaration(propertyKey);\n\n        if (propertyDeclaration && propertyDeclaration.notify) {\n\n            if (isPropertyNotifier(propertyDeclaration.notify)) {\n\n                try {\n                    propertyDeclaration.notify.call(this, propertyKey, oldValue, newValue);\n\n                } catch (error) {\n\n                    throw PROPERTY_NOTIFIER_ERROR(propertyDeclaration.notify.toString());\n                }\n\n            } else if (isPropertyKey(propertyDeclaration.notify)) {\n\n                try {\n                    (this[propertyDeclaration.notify] as PropertyNotifier)(propertyKey, oldValue, newValue);\n\n                } catch (error) {\n\n                    throw PROPERTY_NOTIFIER_ERROR(propertyDeclaration.notify);\n                }\n\n            } else {\n\n                this._notifyProperty(propertyKey, oldValue, newValue);\n            }\n        }\n    }\n\n    /**\n     * The default attribute reflector\n     *\n     * @remarks\n     * If no {@link AttributeReflector} is defined in the {@link PropertyDeclaration} this\n     * method is used to reflect the attribute value to its associated property.\n     *\n     * @param attributeName The name of the attribute to reflect\n     * @param oldValue      The old attribute value\n     * @param newValue      The new attribute value\n     *\n     * @internal\n     * @private\n     */\n    protected _reflectAttribute (attributeName: string, oldValue: string | null, newValue: string | null) {\n\n        const constructor = this.constructor as typeof CustomElement;\n\n        const propertyKey = constructor.attributes.get(attributeName)!;\n\n        const propertyDeclaration = this.getPropertyDeclaration(propertyKey)!;\n\n        const propertyValue = propertyDeclaration.converter.fromAttribute(newValue);\n\n        this[propertyKey as keyof this] = propertyValue;\n    }\n\n    /**\n     * The default property reflector\n     *\n     * @remarks\n     * If no {@link PropertyReflector} is defined in the {@link PropertyDeclaration} this\n     * method is used to reflect the property value to its associated attribute.\n     *\n     * @param propertyKey   The property key of the property to reflect\n     * @param oldValue      The old property value\n     * @param newValue      The new property value\n     *\n     * @internal\n     * @private\n     */\n    protected _reflectProperty (propertyKey: PropertyKey, oldValue: any, newValue: any) {\n\n        // this function is only called for properties which have a declaration\n        const propertyDeclaration = this.getPropertyDeclaration(propertyKey)!;\n\n        // if the default reflector is used, we need to check if an attribute for this property exists\n        // if not, we won't reflect\n        if (!propertyDeclaration.attribute) return;\n\n        // if attribute is truthy, it's a string\n        const attributeName = propertyDeclaration.attribute as string;\n\n        // resolve the attribute value\n        const attributeValue = propertyDeclaration.converter.toAttribute(newValue);\n\n        // undefined means don't change\n        if (attributeValue === undefined) {\n\n            return;\n        }\n        // null means remove the attribute\n        else if (attributeValue === null) {\n\n            this.removeAttribute(attributeName);\n\n        } else {\n\n            this.setAttribute(attributeName, attributeValue);\n        }\n    }\n\n    /**\n     * Dispatch a property-changed event\n     *\n     * @param propertyKey\n     * @param oldValue\n     * @param newValue\n     *\n     * @internal\n     * @private\n     */\n    protected _notifyProperty (propertyKey: PropertyKey, oldValue: any, newValue: any): void {\n\n        const eventName = createEventName(propertyKey, '', 'changed');\n\n        this.dispatchEvent(new CustomEvent(eventName, {\n            bubbles: true,\n            composed: true,\n            cancelable: true,\n            detail: {\n                property: propertyKey,\n                previous: oldValue,\n                current: newValue,\n            },\n        }));\n    }\n\n    /**\n     * Dispatch a lifecycle event\n     *\n     * @param lifecycle The lifecycle for which to raise the event\n     * @param detail    Optional event details\n     *\n     * @internal\n     * @private\n     */\n    protected _notifyLifecycle (lifecycle: string, detail?: object) {\n\n        const eventName = createEventName(lifecycle, 'on');\n\n        const eventInit = {\n            composed: true,\n            ...(detail ? { detail: detail } : {})\n        };\n\n        this.dispatchEvent(new CustomEvent(eventName, eventInit));\n    }\n\n    /**\n     * Bind custom element listeners.\n     *\n     * @internal\n     * @private\n     */\n    protected _listen () {\n\n        (this.constructor as typeof CustomElement).listeners.forEach((declaration, listener) => {\n\n            const instanceDeclaration: InstanceListenerDeclaration = {\n\n                // copy the class's static listener declaration into an instance listener declaration\n                event: declaration.event,\n                options: declaration.options,\n\n                // bind the components listener method to the component instance and store it in the instance declaration\n                listener: (this[listener as keyof this] as unknown as EventListener).bind(this),\n\n                // determine the event target and store it in the instance declaration\n                target: (declaration.target)\n                    ? (typeof declaration.target === 'function')\n                        ? declaration.target.call(this)\n                        : declaration.target\n                    : this\n            };\n\n            // add the bound event listener to the target\n            instanceDeclaration.target.addEventListener(instanceDeclaration.event as string, instanceDeclaration.listener, instanceDeclaration.options);\n\n            // save the instance listener declaration on the component instance\n            this._listenerDeclarations.push(instanceDeclaration);\n        });\n    }\n\n    /**\n     * Unbind custom element listeners.\n     *\n     * @internal\n     * @private\n     */\n    protected _unlisten () {\n\n        this._listenerDeclarations.forEach((declaration) => {\n\n            declaration.target.removeEventListener(declaration.event as string, declaration.listener, declaration.options);\n        });\n    }\n\n    /**\n     * Schedule the update of the custom element\n     *\n     * @remarks\n     * Schedules the first update of the custom element as soon as possible and all consecutive updates\n     * just before the next frame.\n     */\n    protected _scheduleUpdate (): Promise<void> | void {\n\n        if (!this._hasUpdated) {\n\n            this._performUpdate();\n\n        } else {\n\n            // schedule the update via requestAnimationFrame to avoid multiple redraws per frame\n            return new Promise(resolve => requestAnimationFrame(() => {\n\n                this._performUpdate();\n\n                resolve();\n            }));\n        }\n    }\n\n    /**\n     * Perform the custom element update\n     *\n     * @remarks\n     * Invokes {@link updateCallback} after performing the update and cleans up the custom element\n     * state. During the first update the element's styles will be added. Dispatches the update\n     * lifecycle event.\n     *\n     * @internal\n     * @private\n     */\n    private _performUpdate () {\n\n        // we have to wait until the custom element is connected before we can do any updates\n        // the {@link connectedCallback} will call {@link requestUpdate} in any case, so we can\n        // simply bypass any actual update and clean-up until then\n        if (this.isConnected) {\n\n            this.update();\n\n            // in the first update we adopt the element's styles and set up declared listeners\n            if (!this._hasUpdated) {\n\n                this.adoptStyles();\n\n                // bind listeners after the update, this way we ensure all DOM is rendered, all properties\n                // are up-to-date and any user-created objects (e.g. workers) will be created in an\n                // overridden connectedCallback\n                // TODO: test overriding the connectedCallback and creating objects, which will be listener targets\n                this._listen();\n            }\n\n            this.updateCallback(this._changedProperties, !this._hasUpdated);\n\n            this._notifyLifecycle('update', { firstUpdate: !this._hasUpdated });\n\n            this._hasUpdated = true;\n\n            this._changedProperties = new Map();\n\n            this._reflectingProperties = new Map();\n\n            this._notifyingProperties = new Map();\n        }\n\n        // mark custom element as updated *after* the update to prevent infinte loops in the update process\n        // N.B.: any property changes during the update will be ignored\n        this._hasRequestedUpdate = false;\n    }\n\n    /**\n     * Enqueue a request for an asynchronous update\n     *\n     * @internal\n     * @private\n     */\n    private async _enqueueUpdate () {\n\n        let resolve: (result: boolean) => void;\n\n        const previousRequest = this._updateRequest;\n\n        // mark the custom element as having requested an update, the {@link _requestUpdate} method\n        // will not enqueue a further request for update if one is scheduled\n        this._hasRequestedUpdate = true;\n\n        this._updateRequest = new Promise<boolean>(res => resolve = res);\n\n        // wait for the previous update to resolve\n        // `await` is asynchronous and will return execution to the {@link requestUpdate} method\n        // and essentially allows us to batch multiple synchronous property changes, before the\n        // execution can resume here\n        await previousRequest;\n\n        const result = this._scheduleUpdate();\n\n        // the actual update may be scheduled asynchronously as well\n        if (result) await result;\n\n        // resolve the new {@link _updateRequest} after the result of the current update resolves\n        resolve!(!this._hasRequestedUpdate);\n    }\n}\n","import { CustomElement } from '../custom-element';\nimport { TemplateResult } from 'lit-html';\n\n/**\n * A {@link CustomElement} declaration\n */\nexport interface CustomElementDeclaration<Type extends CustomElement = CustomElement> {\n    /**\n     * The selector of the custom element\n     *\n     * @remarks\n     * The selector will be used to register the custom element constructor with the browser's\n     * {@link window.customElements} API. If no selector is specified, the custom element class\n     * needs to provide one in its static {@link CustomElement.selector} property.\n     * A selector defined in the {@link CustomElementDeclaration} will take precedence over the\n     * static class property.\n     */\n    selector: string;\n    /**\n     * Use Shadow DOM to render the custom elements template?\n     *\n     * @remarks\n     * Shadow DOM can be disabled by setting this option to `false`, in which case the custom\n     * element's template will be rendered as child nodes of the custom element. This can be\n     * useful if an isolated DOM and scoped CSS is not desired.\n     *\n     * Default value: `true`\n     */\n    shadow: boolean;\n    /**\n     * Automatically register the custom element with the browser's {@link window.customElements} API?\n     *\n     * @remarks\n     * In cases where you want to employ a module system which registers custom elements on\n     * a conditional basis, you can disable automatic registration by setting this option to\n     * `false`. Your module or bootstrap system will have to take care of defining the custom\n     * element later.\n     *\n     * Default value: `true`\n     */\n    define: boolean;\n    // TODO: test media queries\n    /**\n     * The custom element's styles\n     *\n     * @remarks\n     * An array of CSS rulesets (https://developer.mozilla.org/en-US/docs/Web/CSS/Syntax#CSS_rulesets).\n     * Styles defined using the decorator will be merged with styles defined in the custom element's\n     * static {@link CustomElement.styles} getter.\n     *\n     * ```typescript\n     * @customElement({\n     *      styles: [\n     *          'h1, h2 { font-size: 16pt; }',\n     *          '@media screen and (min-width: 900px) { article { padding: 1rem 3rem; } }'\n     *      ]\n     * })\n     * ```\n     *\n     * Default value: `undefined`\n     */\n    styles?: string[];\n    // TODO: update documentation\n    /**\n     * The custom element's template\n     *\n     * @remarks\n     * A static function which returns a {@link #lit-html.TemplateResult}. The function's `element`\n     * parameter will be the current custom element instance. This function will be invoked by the\n     * custom element's render method.\n     *\n     * The method must return a {@link lit-html#TemplateResult} which is created using lit-html's\n     * {@link lit-html#html | `html`} or {@link lit-html#svg | `svg`} template methods.\n     *\n     * Default value: `undefined`\n     *\n     * @param element The custom element instance requesting the template\n     */\n    template?: (element: Type, ...helpers: any[]) => TemplateResult | void;\n}\n\nexport const DEFAULT_CUSTOM_ELEMENT_DECLARATION: CustomElementDeclaration = {\n    selector: '',\n    shadow: true,\n    define: true,\n};\n","import { CustomElement } from '../custom-element';\nimport { CustomElementDeclaration, DEFAULT_CUSTOM_ELEMENT_DECLARATION } from './custom-element-declaration';\nimport { DecoratedCustomElementType } from './property';\n\n/**\n * Decorates a {@link CustomElement} class\n *\n * @param options A custom element declaration\n */\nexport function customElement<Type extends CustomElement = CustomElement> (options: Partial<CustomElementDeclaration<Type>> = {}) {\n\n    const declaration = { ...DEFAULT_CUSTOM_ELEMENT_DECLARATION, ...options };\n\n    return (target: typeof CustomElement) => {\n\n        const constructor = target as DecoratedCustomElementType;\n\n        constructor.selector = declaration.selector || target.selector;\n        constructor.shadow = declaration.shadow;\n        constructor.template = declaration.template || target.template;\n\n        // use keyof signatures to catch refactoring errors\n        const observedAttributesKey: keyof typeof CustomElement = 'observedAttributes';\n        const stylesKey: keyof typeof CustomElement = 'styles';\n\n        /**\n         * Property decorators get called before class decorators, so at this point all decorated properties\n         * have stored their associated attributes in {@link CustomElement.attributes}.\n         * We can now combine them with the user-defined {@link CustomElement.observedAttributes} and,\n         * by using a Set, eliminate all duplicates in the process.\n         *\n         * As the user-defined {@link CustomElement.observedAttributes} will also include decorator generated\n         * observed attributes, we always inherit all observed attributes from a base class. For that reason\n         * we have to keep track of attribute overrides when extending any {@link CustomElement} base class.\n         * This is done in the {@link property} decorator. Here we have to make sure to remove overridden\n         * attributes.\n         */\n        const observedAttributes = [\n            ...new Set(\n                // we take the inherited observed attributes...\n                constructor.observedAttributes\n                    // ...remove overridden generated attributes...\n                    .reduce((attributes, attribute) => attributes.concat(\n                        constructor.overridden && constructor.overridden.has(attribute) ? [] : attribute),\n                        [] as string[]\n                    )\n                    // ...and recombine the list with the newly generated attributes (the Set prevents duplicates)\n                    .concat([...target.attributes.keys()])\n            )\n        ];\n\n        // delete the overridden Set from the constructor\n        delete constructor.overridden;\n\n        /**\n         * We don't want to inherit styles automatically, unless explicitly requested, so we check if the\n         * constructor declares a static styles property (which may use super.styles to explicitly inherit)\n         * and if it doesn't, we ignore the parent class's styles (by not invoking the getter).\n         * We then merge the decorator defined styles (if existing) into the styles and remove duplicates\n         * by using a Set.\n         */\n        const styles = [\n            ...new Set(\n                (constructor.hasOwnProperty(stylesKey)\n                    ? constructor.styles\n                    : []\n                ).concat(declaration.styles || [])\n            )\n        ];\n\n        /**\n         * Finally we override the {@link CustomElement.observedAttributes} getter with a new one, which returns\n         * the unique set of user defined and decorator generated observed attributes.\n         */\n        Reflect.defineProperty(constructor, observedAttributesKey, {\n            configurable: true,\n            enumerable: false,\n            get (): string[] {\n                return observedAttributes;\n            }\n        });\n\n        /**\n         * We override the {@link CustomElement.styles} getter with a new one, which returns\n         * the unique set of statically defined and decorator defined styles.\n         */\n        Reflect.defineProperty(constructor, stylesKey, {\n            configurable: true,\n            enumerable: true,\n            get (): string[] {\n                return styles;\n            }\n        });\n\n        if (declaration.define) {\n\n            window.customElements.define(constructor.selector, constructor);\n        }\n    };\n};\n","import { CustomElement } from '../custom-element';\n\n/**\n * A {@link CustomElement} event listener declaration\n */\nexport interface ListenerDeclaration<Type extends CustomElement = CustomElement> {\n\n    /**\n     * The event to listen to\n     *\n     * @remarks\n     * Setting event to `null` allows to unbind an inherited event listener.\n     */\n    event: string | null;\n\n    /**\n     * An options object that specifies characteristics about the event listener\n     */\n    options?: AddEventListenerOptions;\n\n    /**\n     * An alternative event target (by default this will be the {@link CustomElement} instance)\n     *\n     * @remarks\n     * This can be useful if you want to listen to e.g.:\n     * * window.onresize\n     * * document.onload\n     * * document.onscroll\n     * * Worker.onmessage\n     *\n     * If a function is provided, the function will be invoked by custom element after its\n     * {@link connectedCallback} has updated the custom element. The context of the function will\n     * be the custom element instance.\n     *\n     * ```typescript\n     * class MyElement extends CustomElement {\n     *\n     *      worker: Worker;\n     *\n     *      connectedCallback () {\n     *          super.connectedCallback();\n     *          this.worker = new Worker('worker.js');\n     *      }\n     *\n     *      disconnectedCallback () {\n     *          super.disconnectedCallback()\n     *          this.worker.terminate();\n     *      }\n     *\n     *      @listener<MyElement>({\n     *          event: 'message',\n     *          target: () => this.worker\n     *      })\n     *      onMessage (event: MessageEvent) {\n     *          // do something with event.data\n     *      }\n     * }\n     * ```\n     */\n    target?: EventTarget | ((this: Type) => EventTarget);\n}\n\n/**\n * Decorates a {@link CustomElement} method as an event listener\n *\n * @param options The listener declaration\n */\nexport function listener<Type extends CustomElement = CustomElement> (options: ListenerDeclaration<Type>) {\n\n    return function (target: Object, propertyKey: string, descriptor: PropertyDescriptor) {\n\n        const constructor = target.constructor as typeof CustomElement;\n\n        prepareConstructor(constructor);\n\n        if (options.event === null) {\n\n            constructor.listeners.delete(propertyKey);\n\n        } else {\n\n            constructor.listeners.set(propertyKey, { ...options } as ListenerDeclaration);\n        }\n    }\n}\n\n/**\n * Prepares the custom element constructor by initializing static properties for the listener decorator,\n * so we don't modify a base class's static properties.\n *\n * @remarks\n * When the listener decorator stores listener declarations in the constructor, we have to make sure the\n * static listeners field is initialized on the current constructor. Otherwise we add listener declarations\n * to the base class's static field. We also make sure to initialize the listener maps with the values of\n * the base class's map to properly inherit all listener declarations.\n *\n * @param constructor The custom element constructor to prepare\n *\n * @internal\n * @private\n */\nfunction prepareConstructor (constructor: typeof CustomElement) {\n\n    if (!constructor.hasOwnProperty('listeners')) constructor.listeners = new Map(constructor.listeners);\n}\n","import { CustomElement } from '../custom-element';\nimport { createAttributeName, DEFAULT_PROPERTY_DECLARATION, PropertyDeclaration } from './property-declaration';\nimport { getPropertyDescriptor } from './utils/get-property-descriptor';\n\n/**\n * A type extension to add additional properties to a {@link CustomElement} constructor during decoration\n *\n * @internal\n * @private\n */\nexport type DecoratedCustomElementType = typeof CustomElement & { overridden?: Set<string> };\n\n/**\n * Decorates a {@link CustomElement} property\n *\n * @remarks\n * Many of the {@link PropertyDeclaration} options support custom functions, which will be invoked\n * with the custom element instance as `this`-context during execution. In order to support correct\n * typing in these functions, the `@property` decorator supports generic types. Here is an example\n * of how you can use this with a custom {@link PropertyReflector}:\n *\n * ```typescript\n * class MyElement extends CustomElement {\n *\n *      myHiddenProperty = true;\n *\n *      // use a generic to support proper instance typing in the property reflector\n *      @property<MyElement>({\n *          reflectProperty: (propertyKey: string, oldValue: any, newValue: any) {\n *              // the generic type allows for correct typing of this\n *              if (this.myHiddenProperty && newValue) {\n *                  this.setAttribute('my-property', '');\n *              } else {\n *                  this.removeAttribute('my-property');\n *              }\n *          }\n *      })\n *      myProperty = false;\n * }\n * ```\n *\n * @param options A property declaration\n */\nexport function property<Type extends CustomElement = CustomElement> (options: Partial<PropertyDeclaration<Type>> = {}) {\n\n    return function (\n        target: Object,\n        propertyKey: PropertyKey,\n        propertyDescriptor?: PropertyDescriptor,\n    ): any {\n\n        /**\n         * When defining classes in TypeScript, class fields actually don't exist on the class's prototype, but\n         * rather, they are instantiated in the constructor and exist only on the instance. Accessor properties\n         * are an exception however and exist on the prototype. Furthermore, accessors are inherited and will\n         * be invoked when setting (or getting) a property on an instance of a child class, even if that class\n         * defines the property field on its own. Only if the child class defines new accessors will the parent\n         * class's accessors not be inherited.\n         * To keep this behavior intact, we need to ensure, that when we create accessors for properties, which\n         * are not declared as accessors, we invoke the parent class's accessor as expected.\n         * The {@link getPropertyDescriptor} function allows us to look for accessors on the prototype chain of\n         * the class we are decorating.\n         */\n        const descriptor = propertyDescriptor || getPropertyDescriptor(target, propertyKey);\n        const hiddenKey = (typeof propertyKey === 'string') ? `__${ propertyKey }` : Symbol();\n\n        // if we found an accessor descriptor (from either this class or a parent) we use it, otherwise we create\n        // default accessors to store the actual property value in a hidden field and retrieve it from there\n        const getter = descriptor && descriptor.get || function (this: any) { return this[hiddenKey]; };\n        const setter = descriptor && descriptor.set || function (this: any, value: any) { this[hiddenKey] = value; };\n\n        // we define a new accessor descriptor which will wrap the previously retrieved or created accessors\n        // and request an update of the custom element whenever the property is set\n        const wrappedDescriptor: PropertyDescriptor & ThisType<any> = {\n            configurable: true,\n            enumerable: true,\n            get (): any {\n                return getter.call(this);\n            },\n            set (value: any): void {\n                const oldValue = this[propertyKey];\n                setter.call(this, value);\n                this.requestUpdate(propertyKey, oldValue, value);\n            }\n        }\n\n        const constructor = target.constructor as DecoratedCustomElementType;\n\n        const declaration: PropertyDeclaration<Type> = { ...DEFAULT_PROPERTY_DECLARATION, ...options };\n\n        // generate the default attribute name\n        if (declaration.attribute === true) {\n\n            declaration.attribute = createAttributeName(propertyKey);\n        }\n\n        // set the default property change detector\n        if (declaration.observe === true) {\n\n            declaration.observe = DEFAULT_PROPERTY_DECLARATION.observe;\n        }\n\n        prepareConstructor(constructor);\n\n        // check if we inherited an observed attribute for the property from the base class\n        const attribute = constructor.properties.has(propertyKey) ? constructor.properties.get(propertyKey)!.attribute : undefined;\n\n        // if attribute is truthy it's a string and it will exist in the attributes map\n        if (attribute) {\n\n            // remove the inherited attribute as it's overridden\n            constructor.attributes.delete(attribute as string);\n            // mark attribute as overridden for {@link customElement} decorator\n            constructor.overridden!.add(attribute as string);\n        }\n\n        if (declaration.attribute) {\n\n            constructor.attributes.set(declaration.attribute, propertyKey);\n        }\n\n        // store the property declaration *after* processing the attributes, so we can still access the\n        // inherited property declaration when processing the attributes\n        constructor.properties.set(propertyKey, declaration as PropertyDeclaration);\n\n        if (!propertyDescriptor) {\n\n            // if no propertyDescriptor was defined for this decorator, this decorator is a property\n            // decorator which must return void and we can define the wrapped descriptor here\n            Object.defineProperty(target, propertyKey, wrappedDescriptor);\n\n        } else {\n\n            // if a propertyDescriptor was defined for this decorator, this decorator is an accessor\n            // decorator and we must return the wrapped property descriptor\n            return wrappedDescriptor;\n        }\n    };\n};\n\n/**\n * Prepares the custom element constructor by initializing static properties for the property decorator,\n * so we don't modify a base class's static properties.\n *\n * @remarks\n * When the property decorator stores property declarations and attribute mappings in the constructor,\n * we have to make sure those static fields are initialized on the current constructor. Otherwise we\n * add property declarations and attribute mappings to the base class's static fields. We also make\n * sure to initialize the constructors maps with the values of the base class's maps to properly\n * inherit all property declarations and attributes.\n *\n * @param constructor The custom element constructor to prepare\n *\n * @internal\n * @private\n */\nfunction prepareConstructor (constructor: DecoratedCustomElementType) {\n\n    // this will give us a compile-time error if we refactor one of the static constructor properties\n    // and we won't miss renaming the property keys\n    const properties: keyof DecoratedCustomElementType = 'properties';\n    const attributes: keyof DecoratedCustomElementType = 'attributes';\n    const overridden: keyof DecoratedCustomElementType = 'overridden';\n\n    if (!constructor.hasOwnProperty(properties)) constructor.properties = new Map(constructor.properties);\n    if (!constructor.hasOwnProperty(attributes)) constructor.attributes = new Map(constructor.attributes);\n    if (!constructor.hasOwnProperty(overridden)) constructor.overridden = new Set();\n}\n","/**\n * Get the {@link PropertyDescriptor} of a property from its prototype\n * or a parent prototype - excluding {@link Object.prototype} itself.\n *\n * @param target        The prototype to get the descriptor from\n * @param propertyKey   The property key for which to get the descriptor\n *\n * @internal\n * @private\n */\nexport function getPropertyDescriptor (target: Object, propertyKey: PropertyKey): PropertyDescriptor | undefined {\n\n    if (propertyKey in target) {\n\n        while (target !== Object.prototype) {\n\n            if (target.hasOwnProperty(propertyKey)) {\n\n                return Object.getOwnPropertyDescriptor(target, propertyKey);\n            }\n\n            target = Object.getPrototypeOf(target);\n        }\n    }\n\n    return undefined;\n}\n"],"names":["AttributeConverterDefault","fromAttribute","value","JSON","parse","error","toAttribute","stringify","toString","AttributeConverterBoolean","AttributeConverterString","AttributeConverterNumber","Number","AttributeConverterObject","AttributeConverterArray","AttributeConverterDate","Date","SPACES","CAMELS","kebabCase","string","matches","trim","exec","replace","lastIndex","toLowerCase","isAttributeReflector","reflector","isPropertyReflector","isPropertyNotifier","notifier","isPropertyChangeDetector","detector","isPropertyKey","key","encodeAttribute","createAttributeName","propertyKey","String","createEventName","prefix","suffix","propertyString","DEFAULT_PROPERTY_CHANGE_DETECTOR","oldValue","newValue","DEFAULT_PROPERTY_DECLARATION","attribute","converter","reflectAttribute","reflectProperty","notify","observe","ATTRIBUTE_REFLECTOR_ERROR","attributeReflector","Error","PROPERTY_REFLECTOR_ERROR","propertyReflector","PROPERTY_NOTIFIER_ERROR","propertyNotifier","CHANGE_DETECTOR_ERROR","changeDetector","CustomElement","HTMLElement","[object Object]","super","this","Promise","resolve","Map","_renderRoot","createRenderRoot","styleSheet","_styleSheet","CSSStyleSheet","replaceSync","styles","join","observedAttributes","_notifyLifecycle","requestUpdate","_unlisten","_hasUpdated","_isReflecting","changedProperties","firstUpdate","constructor","shadow","attachShadow","mode","adoptedStyleSheets","document","includes","length","Array","from","styleSheets","find","style","title","selector","createElement","textContent","appendChild","head","helpers","template","render","eventContext","eventName","eventInit","dispatchEvent","CustomEvent","executor","previousChanges","_changedProperties","has","hasChanged","get","_notifyingProperties","set","_updateRequest","_reflectingProperties","_hasRequestedUpdate","_enqueueUpdate","forEach","notifyProperty","properties","propertyDeclaration","getPropertyDeclaration","call","attributeName","attributes","console","log","_reflectAttribute","_reflectProperty","_notifyProperty","propertyValue","attributeValue","undefined","removeAttribute","setAttribute","bubbles","composed","cancelable","detail","property","previous","current","lifecycle","listeners","declaration","listener","instanceDeclaration","event","options","bind","target","addEventListener","_listenerDeclarations","push","removeEventListener","requestAnimationFrame","_performUpdate","isConnected","update","adoptStyles","_listen","updateCallback","previousRequest","res","result","_scheduleUpdate","DEFAULT_CUSTOM_ELEMENT_DECLARATION","define","customElement","Set","reduce","concat","overridden","keys","hasOwnProperty","Reflect","defineProperty","configurable","enumerable","window","customElements","descriptor","prepareConstructor","delete","Object","propertyDescriptor","prototype","getOwnPropertyDescriptor","getPrototypeOf","getPropertyDescriptor","hiddenKey","Symbol","getter","setter","wrappedDescriptor","add"],"mappings":"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"}