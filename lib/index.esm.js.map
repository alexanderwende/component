{"version":3,"file":"index.esm.js","sources":["../src/utils/string-utils.ts","../src/custom-element.ts","../src/decorators/attribute-converter.ts","../src/decorators/custom-element.ts","../src/decorators/listener.ts","../src/decorators/property-declaration.ts","../src/decorators/property.ts"],"sourcesContent":["const FIRST = /^[^]/;\nconst SPACES = /\\s+([\\S])/g;\nconst CAMELS = /[a-z]([A-Z])/g;\nconst KEBABS = /-([a-z])/g;\n\nexport function capitalize (string: string): string {\n\n    return string ? string.replace(FIRST, string[0].toUpperCase()) : string;\n}\n\nexport function uncapitalize (string: string): string {\n\n    return string ? string.replace(FIRST, string[0].toLowerCase()) : string;\n}\n\nexport function camelCase (string: string): string {\n\n    let matches;\n\n    if (string) {\n\n        string = string.trim();\n\n        while ((matches = SPACES.exec(string))) {\n\n            string = string.replace(matches[0], matches[1].toUpperCase());\n\n            SPACES.lastIndex = 0;\n        }\n\n        while ((matches = KEBABS.exec(string))) {\n\n            string = string.replace(matches[0], matches[1].toUpperCase());\n\n            KEBABS.lastIndex = 0;\n        }\n    }\n\n    return uncapitalize(string);\n}\n\nexport function kebabCase (string: string): string {\n\n    let matches;\n\n    if (string) {\n\n        string = string.trim();\n\n        while ((matches = SPACES.exec(string))) {\n\n            string = string.replace(matches[0], '-' + matches[1]);\n\n            SPACES.lastIndex = 0;\n        }\n\n        while ((matches = CAMELS.exec(string))) {\n\n            string = string.replace(matches[0], matches[0][0] + '-' + matches[1]);\n\n            CAMELS.lastIndex = 0;\n        }\n    }\n\n    return string ? string.toLowerCase() : string;\n}\n","import { html, render, TemplateResult } from 'lit-html';\nimport { ListenerDeclaration } from './decorators/listener';\nimport { PropertyDeclaration, PropertyNotifier, PropertyReflector } from \"./decorators/property-declaration\";\nimport { kebabCase } from './utils/string-utils';\n\nconst PROPERTY_REFLECTOR_ERROR = (propertyReflector: string) => new Error(`Error executing property reflector ${ propertyReflector }.`);\nconst PROPERTY_NOTIFIER_ERROR = (propertyNotifier: string) => new Error(`Error executing property notifier ${ propertyNotifier }.`);\n\n/**\n * Extends the static {@link ListenerDeclaration} to include the bound listener\n */\ninterface InstanceListenerDeclaration extends ListenerDeclaration {\n\n    /**\n     * The bound listener will be stored here, so it can be removed it later\n     */\n    listener: EventListener;\n\n    /**\n     * The event target will always be resolved to an actual {@link EventTarget}\n     */\n    target: EventTarget;\n}\n\nexport interface CustomElementType<T extends CustomElement = CustomElement> {\n\n    selector: string;\n\n    shadow: boolean;\n\n    propertyDeclarations: { [key: string]: PropertyDeclaration<T> };\n\n    listenerDeclarations: { [key: string]: ListenerDeclaration };\n\n    new(...args: any[]): T;\n}\n\nexport class CustomElement extends HTMLElement {\n\n    static selector: string;\n\n    static shadow: boolean;\n\n    static propertyDeclarations: { [key: string]: PropertyDeclaration } = {};\n\n    static listenerDeclarations: { [key: string]: ListenerDeclaration } = {};\n\n    static get observedAttributes (): string[] {\n\n        return [];\n    }\n\n    protected _renderRoot: Element | DocumentFragment;\n\n    protected _updateRequest: Promise<boolean> = Promise.resolve(true);\n\n    protected _changedProperties: Map<string, any> = new Map();\n\n    protected _notifyingProperties: Map<string, any> = new Map();\n\n    protected _listenerDeclarations: InstanceListenerDeclaration[] = [];\n\n    protected _isConnected = false;\n\n    protected _hasRequestedUpdate = false;\n\n    protected _isReflecting = false;\n\n    get isConnected (): boolean {\n\n        return this._isConnected;\n    }\n\n    constructor () {\n\n        super();\n\n        this._renderRoot = this.createRenderRoot();\n\n        console.log('constructed... ', this.constructor.name);\n    }\n\n    createRenderRoot (): Element | DocumentFragment {\n\n        return (this.constructor as CustomElementType).shadow ?\n            this.attachShadow({ mode: 'open' }) :\n            this;\n    }\n\n    adoptedCallback (): void {\n    }\n\n    connectedCallback (): void {\n\n        console.log('connected... ', this.constructor.name);\n\n        this._listen();\n\n        this.requestUpdate();\n    }\n\n    disconnectedCallback (): void {\n\n        console.log('disconnected... ', this.constructor.name);\n\n        this._unlisten();\n    }\n\n    attributeChangedCallback (attribute: string, oldValue: any, newValue: any): void {\n    }\n\n    propertyChangedCallback (property: string, oldValue: any, newValue: any): void {\n    }\n\n    template (): TemplateResult {\n\n        return html``;\n    }\n\n    render (): void {\n\n        console.log('render()... ', this.constructor.name);\n\n        render(this.template(), this._renderRoot);\n\n        this.renderCallback();\n    }\n\n    renderCallback (): void {\n\n        console.log('rendered... ', this.constructor.name);\n    }\n\n    update (changedProperties: Map<string, any>): void {\n\n        console.log('update()... ', changedProperties);\n\n        // TODO: Check if at least one changed property requests render\n        this.render();\n\n        changedProperties.forEach((oldValue: any, propertyKey: string) => {\n\n            // properties in the changedProperties map will always have a declaration\n            const propertyDeclaration = this._getPropertyDeclaration(propertyKey)!;\n            const newValue = this[propertyKey as keyof CustomElement];\n\n            // TODO: only reflect if property change was not initiated by observed attribute\n            if (propertyDeclaration.reflectProperty) {\n\n                if (typeof propertyDeclaration.reflectProperty === 'function') {\n\n                    try {\n                        propertyDeclaration.reflectProperty.call(this, propertyKey, oldValue, newValue);\n                    } catch (error) {\n                        throw PROPERTY_REFLECTOR_ERROR(propertyDeclaration.reflectProperty.toString());\n                    }\n\n                } else if (typeof propertyDeclaration.reflectProperty === 'string') {\n\n                    try {\n                        (this[propertyDeclaration.reflectProperty as keyof this] as unknown as PropertyReflector)(propertyKey, oldValue, newValue);\n                    } catch (error) {\n                        throw PROPERTY_REFLECTOR_ERROR(propertyDeclaration.reflectProperty);\n                    }\n\n                } else {\n\n                    this._reflect(propertyKey, oldValue, newValue);\n                }\n            }\n        });\n\n        this._notifyingProperties.forEach((oldValue, propertyKey) => {\n\n            const propertyDeclaration = this._getPropertyDeclaration(propertyKey)!;\n            const newValue = this[propertyKey as keyof CustomElement];\n\n            if (propertyDeclaration.notify) {\n\n                if (typeof propertyDeclaration.notify === 'function') {\n\n                    try {\n                        propertyDeclaration.notify.call(this, propertyKey, oldValue, newValue);\n                    } catch (error) {\n                        throw PROPERTY_NOTIFIER_ERROR(propertyDeclaration.notify.toString());\n                    }\n\n                } else if (typeof propertyDeclaration.notify === 'string') {\n\n                    try {\n                        (this[propertyDeclaration.notify as keyof this] as unknown as PropertyNotifier)(propertyKey, oldValue, newValue);\n                    } catch (error) {\n                        throw PROPERTY_NOTIFIER_ERROR(propertyDeclaration.notify);\n                    }\n\n                } else {\n\n                    this._notify(propertyKey, oldValue, newValue);\n                }\n            }\n        });\n    }\n\n    /**\n     * Raise custom events for property changes which occurred in the executor\n     *\n     * @remarks\n     * Property changes should trigger custom events when they are caused by internal state changes,\n     * but not if they are caused by a consumer of the custom element API directly, e.g.:\n     *\n     * ```typescript\n     * document.querySelector('my-custom-element').customProperty = true;\n     * ```.\n     *\n     * This means, we cannot automate this process through property setters, as we can't be sure who\n     * invoked the setter - internal calls or external calls.\n     *\n     * One option is to manually raise the event, which can become tedious and forces us to use string-\n     * based event names or property names, which are difficult to refactor, e.g.:\n     *\n     * ```typescript\n     * this.customProperty = true;\n     * // if we refactor the property name, we can easily miss the notify call\n     * this.notify('customProperty');\n     * ```\n     *\n     * A more convenient way is to execute the internal changes in a wrapper which can detect the changed\n     * properties and will automatically raise the required events. This eliminates the need to manually\n     * raise events and refactoring does no longer affect the process.\n     *\n     * @param executor A function that performs the changes which should be notified\n     */\n    notifyChanges (executor: () => void) {\n\n        // back up current changed properties\n        const previousChanges = new Map(this._changedProperties);\n\n        // execute the changes\n        executor();\n\n        // add all new or updated changed properties to the notifying properties\n        for (const [propertyKey, oldValue] of this._changedProperties) {\n\n            if (!previousChanges.has(propertyKey) || previousChanges.get(propertyKey) !== oldValue) {\n\n                this._notifyingProperties.set(propertyKey, oldValue);\n            }\n        }\n    }\n\n    /**\n     * Dispatch a property-changed event.\n     *\n     * @param propertyKey\n     * @param oldValue\n     * @param newValue\n     */\n    protected _notify (propertyKey: string, oldValue: any, newValue: any): void {\n\n        const eventName = `${ kebabCase(propertyKey) }-changed`;\n\n        this.dispatchEvent(new CustomEvent(eventName, {\n            composed: true,\n            detail: {\n                property: propertyKey,\n                previous: oldValue,\n                current: newValue\n            }\n        }));\n\n        console.log(`notify ${ eventName }...`);\n    }\n\n    /**\n     * Reflect a property to an attribute on the custom element.\n     *\n     * @param propertyKey\n     * @param oldValue\n     * @param newValue\n     *\n     * @internal\n     * @private\n     */\n    protected _reflect (propertyKey: string, oldValue: any, newValue: any): void {\n\n        const propertyDeclaration = this._getPropertyDeclaration(propertyKey)!;\n\n        // resolve the attribute name\n        const attributeName = (typeof propertyDeclaration.attribute === 'string') ? propertyDeclaration.attribute : kebabCase(propertyKey);\n        // resolve the attribute value\n        const attributeValue = propertyDeclaration.converter!.toAttribute!(newValue);\n\n        if (attributeValue === undefined) {\n\n            return;\n        }\n        else if (attributeValue === null) {\n\n            this.removeAttribute(attributeName);\n\n        } else {\n\n            this.setAttribute(attributeName, attributeValue);\n        }\n    }\n\n    /**\n     * Bind custom element listeners.\n     *\n     * @internal\n     * @private\n     */\n    protected _listen () {\n\n        Object.entries((this.constructor as CustomElementType).listenerDeclarations).forEach(([listener, declaration]) => {\n\n            const instanceDeclaration: InstanceListenerDeclaration = {\n\n                // copy the class's static listener declaration into an instance listener declaration\n                event: declaration.event,\n                options: declaration.options,\n\n                // bind the components listener method to the component instance and store it in the instance declaration\n                listener: (this[listener as keyof this] as unknown as EventListener).bind(this),\n\n                // determine the event target and store it in the instance declaration\n                target: (declaration.target) ?\n                    (typeof declaration.target === 'function') ?\n                        declaration.target() :\n                        declaration.target :\n                    this\n            };\n\n            // add the bound event listener to the target\n            instanceDeclaration.target.addEventListener(instanceDeclaration.event, instanceDeclaration.listener, instanceDeclaration.options);\n\n            // save the instance listener declaration on the component instance\n            this._listenerDeclarations.push(instanceDeclaration);\n        });\n    }\n\n    /**\n     * Unbind custom element listeners.\n     *\n     * @internal\n     * @private\n     */\n    protected _unlisten () {\n\n        this._listenerDeclarations.forEach((declaration) => {\n\n            declaration.target.removeEventListener(declaration.event, declaration.listener, declaration.options);\n        });\n    }\n\n    requestUpdate (propertyKey?: string, oldValue?: any, newValue?: any): Promise<boolean> {\n\n        console.log('requestUpdate()... ', this.constructor.name);\n\n        const constructor = this.constructor as typeof CustomElement;\n\n        if (propertyKey && propertyKey in constructor.propertyDeclarations) {\n\n            const { observe } = constructor.propertyDeclarations[propertyKey];\n\n            // check if property is observed\n            if (!observe) return this._updateRequest;\n            console.log(`requestUpdate()... ${ propertyKey } observe: ${ !!observe }`);\n\n            // check if property has changed\n            if (typeof observe === 'function' && !observe(oldValue, newValue)) return this._updateRequest;\n            console.log(`requestUpdate()... ${ propertyKey } changed`);\n\n            // store changed property for batch processing\n            this._changedProperties.set(propertyKey, oldValue);\n        }\n\n        if (!this._hasRequestedUpdate) {\n\n            // enqueue update request if none was enqueued already\n            this._enqueueUpdate();\n        }\n\n        return this._updateRequest;\n    }\n\n    protected _performUpdate (): Promise<void> {\n\n        console.log('performUpdate()... ', this.constructor.name);\n\n        return new Promise(resolve => {\n\n            requestAnimationFrame(() => {\n\n                this.update(this._changedProperties);\n\n                this._changedProperties = new Map();\n\n                this._notifyingProperties = new Map();\n\n                // TODO: Should this be moved before the update call?\n                // During the update, other property changes might occur...\n                this._hasRequestedUpdate = false;\n\n                resolve();\n            });\n        });\n    }\n\n    private async _enqueueUpdate () {\n\n        console.log('enqueueUpdate()... ', this.constructor.name);\n\n        let resolve: (result: boolean) => void;\n\n        const previousRequest = this._updateRequest;\n\n        this._hasRequestedUpdate = true;\n\n        this._updateRequest = new Promise<boolean>(res => resolve = res);\n\n        await previousRequest;\n\n        const result = this._performUpdate();\n\n        await result;\n\n        resolve!(!this._hasRequestedUpdate);\n    }\n\n    private _getPropertyDeclaration (propertyKey: string): PropertyDeclaration | undefined {\n\n        return (this.constructor as typeof CustomElement).propertyDeclarations[propertyKey];\n    }\n}\n","/**\n * A function that will map an attribute value to a property value\n */\nexport type AttributeMapper = (value: string | null) => any;\n\n/**\n * A function that will map a property value to an attribute value\n */\nexport type PropertyMapper = (value: any) => string | null | undefined;\n\n/**\n * An object that holds an {@link AttributeMapper} and a {@link PropertyMapper}\n */\nexport interface AttributeConverter {\n    toAttribute?: PropertyMapper;\n    fromAttribute?: AttributeMapper;\n}\n\n/**\n * @internal\n * @private\n */\ntype AttributeConverterTypes = 'default' | 'boolean' | 'string' | 'number' | 'object' | 'array' | 'date';\n\n/**\n * @internal\n * @private\n */\ntype AttributeConverterMap = { [P in AttributeConverterTypes]: AttributeConverter; }\n\n/**\n * A map of reusable {@link AttributeConverter}s\n *\n * @remark\n * For the most common types, a converter exists which can be referenced in the {@link PropertyDeclaration}.\n *\n * ```typescript\n * import { CustomElement, property, ATTRIBUTE_CONVERTERS } from 'custom-element';\n *\n * export class MyElement extends CustomElement {\n *\n *      @property({\n *          converter: ATTRIBUTE_CONVERTERS.boolean\n *      })\n *      myProperty = true;\n * }\n * ```\n *\n * TODO: Write tests for this\n */\nexport const ATTRIBUTE_CONVERTERS: AttributeConverterMap = {\n    default: {\n        fromAttribute: (value: string | null) => {\n            // `JSON.parse()` will throw an error for empty strings - we consider it null\n            if (value === null || value === '') {\n                return null;\n            }\n            else\n                try {\n                    // `JSON.parse()` will successfully parse `boolean`, `number` and `JSON.stringify`'d values\n                    return JSON.parse(value);\n                }\n                catch (error) {\n                    // if it throws, it means we're probably dealing with a regular string\n                    return value;\n                }\n        },\n        toAttribute: (value: any) => {\n            switch (typeof value) {\n                case 'boolean':\n                    return value ? '' : null;\n                case 'object':\n                    return (value == null) ? value : JSON.stringify(value);\n                case 'undefined':\n                    return value;\n                case 'string':\n                    return value;\n                default: // number, bigint, symbol, function\n                    return value.toString();\n            }\n        }\n    },\n    boolean: {\n        fromAttribute: (value: string | null) => (value !== null),\n        toAttribute: (value: boolean) => value ? '' : null\n    },\n    string: {\n        fromAttribute: (value: string | null) => (value === null) ? null : value,\n        // pass through null or undefined\n        toAttribute: (value: string) => value\n    },\n    number: {\n        fromAttribute: (value: string | null) => (value === null) ? null : Number(value),\n        // pass through null or undefined using `value == null`\n        toAttribute: (value: number) => (value == null) ? value : value.toString()\n    },\n    object: {\n        // `JSON.parse()` will throw an error for empty strings - we consider it null\n        fromAttribute: (value: string | null) => (value === null || value === '') ? null : JSON.parse(value),\n        // pass through null or undefined using `value == null`\n        toAttribute: (value: object) => (value == null) ? value : JSON.stringify(value)\n    },\n    array: {\n        // `JSON.parse()` will throw an error for empty strings - we consider it null\n        fromAttribute: (value: string | null) => (value === null || value === '') ? null : JSON.parse(value),\n        // pass through null or undefined using `value == null`\n        toAttribute: (value: object) => (value == null) ? value : JSON.stringify(value)\n    },\n    date: {\n        // `new Date()` will return an `Invalid Date` for empty strings - we consider it null\n        fromAttribute: (value: string | null) => (value === null || value === '') ? null : new Date(value),\n        // pass through null or undefined using `value == null`\n        toAttribute: (value: Date) => (value == null) ? value : value.toString()\n    }\n};\n","import { CustomElementType } from '../custom-element';\n\nexport interface CustomElementDeclaration extends Object {\n    selector?: string;\n    shadow?: boolean;\n    define?: boolean;\n}\n\nexport const DEFAULT_CUSTOM_ELEMENT_DECLARATION: CustomElementDeclaration = {\n    selector: '',\n    shadow: true,\n    define: true\n};\n\nexport const customElement = (options: CustomElementDeclaration = {}) => {\n\n    options = { ...DEFAULT_CUSTOM_ELEMENT_DECLARATION, ...options };\n\n    return (target: CustomElementType) => {\n\n        target.selector = (options.selector) ? options.selector : target.selector;\n        target.shadow = options.shadow!;\n\n        if (options.define) {\n\n            window.customElements.define(target.selector, target);\n        }\n    };\n};\n","import { CustomElementType } from '../custom-element';\n\n/**\n * A {@link CustomElement} event listener declaration\n */\nexport interface ListenerDeclaration {\n\n    /**\n     * The event to listen to\n     */\n    event: string;\n\n    /**\n     * An options object that specifies characteristics about the event listener\n     */\n    options?: AddEventListenerOptions;\n\n    /**\n     * An alternative event target (by default this will be the {@link CustomElement} instance)\n     *\n     * @remarks\n     * This can be useful if you want to listen to e.g.:\n     * * window.onresize\n     * * document.onload\n     * * document.onscroll\n     * * Worker.onmessage - TODO: This could be interesting to solve, we might need to get the worker from the\n     *   component instance, maybe a use case for di @self()\n     */\n    target?: EventTarget | (() => EventTarget);\n}\n\n/**\n * Decorates a {@link CustomElement} method as an event listener\n *\n * @param options The listener declaration\n */\nexport function listener (options: ListenerDeclaration) {\n\n    return function (target: Object, propertyKey: string, descriptor: PropertyDescriptor) {\n\n        const constructor = target.constructor as CustomElementType;\n\n        constructor.listenerDeclarations[propertyKey] = { ...options };\n    }\n}\n","import { CustomElement } from '../custom-element';\nimport { AttributeConverter, ATTRIBUTE_CONVERTERS } from './attribute-converter';\n\n/**\n * A function that will reflect an attribute value to a property\n */\nexport type AttributeReflector<Type extends CustomElement = CustomElement> = (this: Type, attributeName: string, oldValue: string, newValue: string) => void;\n\n/**\n * A function that will reflect a property value to an attribute\n */\nexport type PropertyReflector<Type extends CustomElement = CustomElement> = (this: Type, propertyKey: string, oldValue: any, newValue: any) => void;\n\n/**\n * A function that will dispatch a custom event for a property change\n */\nexport type PropertyNotifier<Type extends CustomElement = CustomElement> = (this: Type, propertyKey: string, oldValue: any, newValue: any) => void;\n\n/**\n * A function that will return `true` if the `oldValue` and the `newValue` of a property are different, `false` otherwise\n */\nexport type PropertyChangeDetector = (oldValue: any, newValue: any) => boolean;\n\n/**\n * A {@link CustomElement} property declaration\n */\nexport interface PropertyDeclaration<Type extends CustomElement = CustomElement> {\n    /**\n     * Does property have an associated attribute?\n     *\n     * @remarks\n     * Possible values:\n     * * `false`: No attribute will be associated with this property\n     * * `true`: The attribute name will be inferred by camel-casing the property name\n     * * `string`: Use the provided string as the associated attribute name\n     *\n     * Default value: `true`\n     */\n    attribute?: boolean | string;\n\n    /**\n     * Customize the conversion of values between property and associated attribute\n     *\n     * @remarks\n     * Converters are only used when {@link reflectProperty} and/or {@link reflectAttribute} are set to true.\n     * If custom reflectors are used, they have to take care or converting the property/attribute values.\n     *\n     * Default value: `ATTRIBUTE_CONVERTERS.default`\n     */\n    converter?: AttributeConverter;\n\n    /**\n     * Should the associated attribute's value be automatically reflected to the property?\n     *\n     * @remarks\n     * Possible values:\n     * * `false`: The attribute value will not be reflected to the property automatically\n     * * `true`: Any attribute change will be reflected automatically to the property using the default attribute reflector\n     * * `string`: A method on the custom element with that name will be invoked to handle the attribute reflection\n     * * `function`: The provided function will be invoked with its `this` context bound to the custom element instance\n     *\n     * Default value: `true`\n     */\n    reflectAttribute?: boolean | keyof Type | AttributeReflector<Type>;\n\n    /**\n     * Should the property value be automatically reflected to the associated attribute?\n     *\n     * @remarks\n     * Possible values:\n     * * `false`: The property value will not be reflected to the associated attribute automatically\n     * * `true`: Any property change will be reflected automatically to the associated attribute using the default property reflector\n     * * `string`: A method on the custom element with that name will be invoked to handle the property reflection\n     * * `function`: The provided function will be invoked with its `this` context bound to the custom element instance\n     *\n     * Default value: `true`\n     */\n    reflectProperty?: boolean | keyof Type | PropertyReflector<Type>;\n\n    /**\n     * Should a property value change raise a custom event?\n     *\n     * @remarks\n     * Possible values:\n     * * `false`: Don't create a custom event for this property\n     * * `true`: Create custom events for this property automatically\n     * * `string`: Use the method with this name on the custom element to create custom events\n     * * `function`: Use the the provided function to create custom events (`this` context will be the custom element instance)\n     *\n     * Default value: `true`\n     */\n    notify?: boolean | keyof Type | PropertyNotifier<Type>;\n\n    /**\n     * Configure how changes of this property should be monitored\n     *\n     * @remarks\n     * By default a decorated property will be observed for changes (through a custom setter for the property).\n     * Any `set`-operation of this property will therefore request an update of the custom element and initiate\n     * a render as well as reflection and notification.\n     *\n     * Possible values:\n     * * `false`: Don't observe changes of this property (this will bypass render, reflection and notification)\n     * * `true`: Observe changes of this property using the {@link DEFAULT_PROPERTY_CHANGE_DETECTOR}\n     * * `string`: Use a method with this name on the custom element to check if property value has changed\n     * * `function`: Use the provided method to check if property value has changed (`this` context will be custom element instance)\n     *\n     * Default value: `true` (uses {@link DEFAULT_PROPERTY_CHANGE_DETECTOR} internally)\n     */\n    observe?: boolean | keyof Type | PropertyChangeDetector;\n}\n\n// TODO: Write tests for this\nexport const DEFAULT_PROPERTY_CHANGE_DETECTOR: PropertyChangeDetector = (oldValue: any, newValue: any) => {\n    // in case `oldValue` and `newValue` are `NaN`, `(NaN !== NaN)` returns `true`,\n    // but `(NaN === NaN || NaN === NaN)` returns `false`\n    return oldValue !== newValue && (oldValue === oldValue || newValue === newValue);\n};\n\n/**\n * The default {@link CustomElement} property declaration\n */\nexport const DEFAULT_PROPERTY_DECLARATION: PropertyDeclaration = {\n    attribute: true,\n    converter: ATTRIBUTE_CONVERTERS.default,\n    reflectAttribute: true,\n    reflectProperty: true,\n    notify: true,\n    observe: DEFAULT_PROPERTY_CHANGE_DETECTOR,\n};\n","import { CustomElement, CustomElementType } from '../custom-element';\nimport { DEFAULT_PROPERTY_DECLARATION, PropertyDeclaration } from './property-declaration';\n\n/**\n * Decorates a {@link CustomElement} property\n *\n * @remarks\n * Many of the {@link PropertyDeclaration} options support custom functions, which will be invoked\n * with the custom element instance as `this`-context during execution. In order to support correct\n * typing in these functions, the `@property` decorator supports generic types. Here is an example\n * of how you can use this with a custom {@link PropertReflector}:\n *\n * ```typescript\n * class MyElement extends CustomElement {\n *\n *      myHiddenProperty = true;\n *\n *      // use a generic to support proper instance typing in the property reflector\n *      @property<MyElement>({\n *          reflectProperty: (propertyKey: string, oldValue: any, newValue: any) {\n *              // the generic type allows for correct typing of this\n *              if (this.myHiddenProperty && newValue) {\n *                  this.setAttribute('my-property', '');\n *              } else {\n *                  this.removeAttribute('my-property');\n *              }\n *          }\n *      })\n *      myProperty = false;\n * }\n * ```\n *\n * @param options The property declaration\n */\nexport const property = <Type extends CustomElement = CustomElement> (options: PropertyDeclaration<Type> = {}) => {\n\n    return (target: Object, propertyKey: string): void => {\n\n        const descriptor = getPropertyDescriptor(target, propertyKey);\n        const hiddenKey = (typeof propertyKey === 'string') ? `_${ propertyKey }` : Symbol();\n        const get = descriptor && descriptor.get || function (this: any) { return this[hiddenKey]; };\n        const set = descriptor && descriptor.set || function (this: any, value: any) { this[hiddenKey] = value; };\n\n        Object.defineProperty(target, propertyKey, {\n            configurable: true,\n            enumerable: true,\n            get (): any {\n                return get.call(this);\n            },\n            set (value: any): void {\n                const oldValue = this[propertyKey];\n                set.call(this, value);\n                this.requestUpdate(propertyKey, oldValue, value);\n            }\n        });\n\n        const constructor = target.constructor as CustomElementType<Type>;\n\n        // TODO: Merge the attribute converter if only one mapper is specified in the options\n        constructor.propertyDeclarations[propertyKey] = { ...DEFAULT_PROPERTY_DECLARATION, ...options };\n    };\n};\n\n/**\n * Get the {@link PropertyDescriptor} of a property from its prototype\n * or a parent prototype - excluding {@link Object.prototype} itself, to\n * ensure correct prototype inheritance.\n *\n * @param target        The prototype to get the descriptor from\n * @param propertyKey   The property key for which to get the descriptor\n *\n * @internal\n * @private\n */\nfunction getPropertyDescriptor (target: Object, propertyKey: string | symbol): PropertyDescriptor | undefined {\n\n    if (propertyKey in target) {\n\n        while (target !== Object.prototype) {\n\n            if (target.hasOwnProperty(propertyKey)) {\n\n                return Object.getOwnPropertyDescriptor(target, propertyKey);\n            }\n\n            target = Object.getPrototypeOf(target);\n        }\n    }\n\n    return undefined;\n}\n"],"names":["SPACES","CAMELS","kebabCase","string","matches","trim","exec","replace","lastIndex","toLowerCase","PROPERTY_REFLECTOR_ERROR","propertyReflector","Error","PROPERTY_NOTIFIER_ERROR","propertyNotifier","CustomElement","HTMLElement","[object Object]","super","this","Promise","resolve","Map","_renderRoot","createRenderRoot","console","log","constructor","name","observedAttributes","isConnected","_isConnected","shadow","attachShadow","mode","_listen","requestUpdate","_unlisten","attribute","oldValue","newValue","property","html","render","template","renderCallback","changedProperties","forEach","propertyKey","propertyDeclaration","_getPropertyDeclaration","reflectProperty","call","error","toString","_reflect","_notifyingProperties","notify","_notify","executor","previousChanges","_changedProperties","has","get","set","eventName","dispatchEvent","CustomEvent","composed","detail","previous","current","attributeName","attributeValue","converter","toAttribute","undefined","removeAttribute","setAttribute","Object","entries","listenerDeclarations","listener","declaration","instanceDeclaration","event","options","bind","target","addEventListener","_listenerDeclarations","push","removeEventListener","propertyDeclarations","observe","_updateRequest","_hasRequestedUpdate","_enqueueUpdate","requestAnimationFrame","update","previousRequest","res","result","_performUpdate","ATTRIBUTE_CONVERTERS","default","fromAttribute","value","JSON","parse","stringify","boolean","number","Number","object","array","date","Date","DEFAULT_CUSTOM_ELEMENT_DECLARATION","selector","define","customElement","window","customElements","descriptor","DEFAULT_PROPERTY_CHANGE_DETECTOR","DEFAULT_PROPERTY_DECLARATION","reflectAttribute","prototype","hasOwnProperty","getOwnPropertyDescriptor","getPrototypeOf","getPropertyDescriptor","hiddenKey","Symbol","defineProperty","configurable","enumerable"],"mappings":"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"}