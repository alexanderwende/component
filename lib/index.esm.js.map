{"version":3,"file":"index.esm.js","sources":["../src/decorators/attribute-converter.ts","../src/decorators/property-declaration.ts","../src/utils/string-utils.ts","../src/custom-element.ts","../src/decorators/custom-element.ts","../src/decorators/listener.ts","../src/decorators/property.ts","../src/decorators/get-property-descriptor.ts"],"sourcesContent":["/**\n * A function that will map an attribute value to a property value\n */\nexport type AttributeMapper = (value: string | null) => any;\n\n/**\n * A function that will map a property value to an attribute value\n */\nexport type PropertyMapper = (value: any) => string | null | undefined;\n\n/**\n * An object that holds an {@link AttributeMapper} and a {@link PropertyMapper}\n */\nexport interface AttributeConverter {\n    toAttribute: PropertyMapper;\n    fromAttribute: AttributeMapper;\n}\n\n/**\n * @internal\n * @private\n */\ntype AttributeConverterTypes = 'default' | 'boolean' | 'string' | 'number' | 'object' | 'array' | 'date';\n\n/**\n * @internal\n * @private\n */\ntype AttributeConverterMap = { [P in AttributeConverterTypes]: AttributeConverter; }\n\n/**\n * A map of reusable {@link AttributeConverter}s\n *\n * @remark\n * For the most common types, a converter exists which can be referenced in the {@link PropertyDeclaration}.\n *\n * ```typescript\n * import { CustomElement, property, ATTRIBUTE_CONVERTERS } from 'custom-element';\n *\n * export class MyElement extends CustomElement {\n *\n *      @property({\n *          converter: ATTRIBUTE_CONVERTERS.boolean\n *      })\n *      myProperty = true;\n * }\n * ```\n *\n * TODO: Write tests for this\n */\nexport const ATTRIBUTE_CONVERTERS: AttributeConverterMap = {\n    default: {\n        fromAttribute: (value: string | null) => {\n            // `JSON.parse()` will throw an error for empty strings - we consider it null\n            if (value === null || value === '') {\n                return null;\n            }\n            else\n                try {\n                    // `JSON.parse()` will successfully parse `boolean`, `number` and `JSON.stringify`'d values\n                    return JSON.parse(value);\n                }\n                catch (error) {\n                    // if it throws, it means we're probably dealing with a regular string\n                    return value;\n                }\n        },\n        toAttribute: (value: any) => {\n            switch (typeof value) {\n                case 'boolean':\n                    return value ? '' : null;\n                case 'object':\n                    return (value == null) ? value : JSON.stringify(value);\n                case 'undefined':\n                    return value;\n                case 'string':\n                    return value;\n                default: // number, bigint, symbol, function\n                    return value.toString();\n            }\n        }\n    },\n    boolean: {\n        fromAttribute: (value: string | null) => (value !== null),\n        toAttribute: (value: boolean) => value ? '' : null\n    },\n    string: {\n        fromAttribute: (value: string | null) => (value === null) ? null : value,\n        // pass through null or undefined\n        toAttribute: (value: string) => value\n    },\n    number: {\n        fromAttribute: (value: string | null) => (value === null) ? null : Number(value),\n        // pass through null or undefined using `value == null`\n        toAttribute: (value: number) => (value == null) ? value : value.toString()\n    },\n    object: {\n        // `JSON.parse()` will throw an error for empty strings - we consider it null\n        fromAttribute: (value: string | null) => (value === null || value === '') ? null : JSON.parse(value),\n        // pass through null or undefined using `value == null`\n        toAttribute: (value: object) => (value == null) ? value : JSON.stringify(value)\n    },\n    array: {\n        // `JSON.parse()` will throw an error for empty strings - we consider it null\n        fromAttribute: (value: string | null) => (value === null || value === '') ? null : JSON.parse(value),\n        // pass through null or undefined using `value == null`\n        toAttribute: (value: object) => (value == null) ? value : JSON.stringify(value)\n    },\n    date: {\n        // `new Date()` will return an `Invalid Date` for empty strings - we consider it null\n        fromAttribute: (value: string | null) => (value === null || value === '') ? null : new Date(value),\n        // pass through null or undefined using `value == null`\n        toAttribute: (value: Date) => (value == null) ? value : value.toString()\n    }\n};\n","import { CustomElement } from '../custom-element';\nimport { AttributeConverter, ATTRIBUTE_CONVERTERS } from './attribute-converter';\n\n/**\n * A function that will reflect an attribute value to a property\n */\nexport type AttributeReflector<Type extends CustomElement = CustomElement> = (this: Type, attributeName: string, oldValue: string, newValue: string) => void;\n\n/**\n * A function that will reflect a property value to an attribute\n */\nexport type PropertyReflector<Type extends CustomElement = CustomElement> = (this: Type, propertyKey: PropertyKey, oldValue: any, newValue: any) => void;\n\n/**\n * A function that will dispatch a custom event for a property change\n */\nexport type PropertyNotifier<Type extends CustomElement = CustomElement> = (this: Type, propertyKey: PropertyKey, oldValue: any, newValue: any) => void;\n\n/**\n * A function that will return `true` if the `oldValue` and the `newValue` of a property are different, `false` otherwise\n */\nexport type PropertyChangeDetector = (oldValue: any, newValue: any) => boolean;\n\n/**\n * A type guard for {@link AttributeReflector}\n *\n * @param reflector A reflector to test\n */\nexport function isAttributeReflector (reflector: any): reflector is AttributeReflector {\n\n    return typeof reflector === 'function';\n}\n\n/**\n * A type guard for {@link PropertyReflector}\n *\n * @param reflector A reflector to test\n */\nexport function isPropertyReflector (reflector: any): reflector is PropertyReflector {\n\n    return typeof reflector === 'function';\n}\n\n/**\n * A type guard for {@link PropertyNotifier}\n *\n * @param notifier A notifier to test\n */\nexport function isPropertyNotifier (notifier: any): notifier is PropertyNotifier {\n\n    return typeof notifier === 'function';\n}\n\n/**\n * A type guard for {@link PropertyKey}\n *\n * @param key A property key to test\n */\nexport function isPropertyKey (key: any): key is PropertyKey {\n\n    return typeof key === 'string' || typeof key === 'number' || typeof key === 'symbol';\n}\n\n/**\n * A {@link CustomElement} property declaration\n */\nexport interface PropertyDeclaration<Type extends CustomElement = CustomElement> {\n    /**\n     * Does property have an associated attribute?\n     *\n     * @remarks\n     * Possible values:\n     * * `false`: No attribute will be associated with this property\n     * * `true`: The attribute name will be inferred by camel-casing the property name\n     * * `string`: Use the provided string as the associated attribute name\n     *\n     * Default value: `true`\n     */\n    attribute: boolean | string;\n\n    /**\n     * Customize the conversion of values between property and associated attribute\n     *\n     * @remarks\n     * Converters are only used when {@link reflectProperty} and/or {@link reflectAttribute} are set to true.\n     * If custom reflectors are used, they have to take care or converting the property/attribute values.\n     *\n     * Default value: `ATTRIBUTE_CONVERTERS.default`\n     */\n    converter: AttributeConverter;\n\n    /**\n     * Should the associated attribute's value be automatically reflected to the property?\n     *\n     * @remarks\n     * Possible values:\n     * * `false`: The attribute value will not be reflected to the property automatically\n     * * `true`: Any attribute change will be reflected automatically to the property using the default attribute reflector\n     * * `string`: A method on the custom element with that name will be invoked to handle the attribute reflection\n     * * `function`: The provided function will be invoked with its `this` context bound to the custom element instance\n     *\n     * Default value: `true`\n     */\n    reflectAttribute: boolean | keyof Type | AttributeReflector<Type>;\n\n    /**\n     * Should the property value be automatically reflected to the associated attribute?\n     *\n     * @remarks\n     * Possible values:\n     * * `false`: The property value will not be reflected to the associated attribute automatically\n     * * `true`: Any property change will be reflected automatically to the associated attribute using the default property reflector\n     * * `string`: A method on the custom element with that name will be invoked to handle the property reflection\n     * * `function`: The provided function will be invoked with its `this` context bound to the custom element instance\n     *\n     * Default value: `true`\n     */\n    reflectProperty: boolean | keyof Type | PropertyReflector<Type>;\n\n    /**\n     * Should a property value change raise a custom event?\n     *\n     * @remarks\n     * Possible values:\n     * * `false`: Don't create a custom event for this property\n     * * `true`: Create custom events for this property automatically\n     * * `string`: Use the method with this name on the custom element to create custom events\n     * * `function`: Use the the provided function to create custom events (`this` context will be the custom element instance)\n     *\n     * Default value: `true`\n     */\n    notify: boolean | keyof Type | PropertyNotifier<Type>;\n\n    /**\n     * Configure how changes of this property should be monitored\n     *\n     * @remarks\n     * By default a decorated property will be observed for changes (through a custom setter for the property).\n     * Any `set`-operation of this property will therefore request an update of the custom element and initiate\n     * a render as well as reflection and notification.\n     *\n     * Possible values:\n     * * `false`: Don't observe changes of this property (this will bypass render, reflection and notification)\n     * * `true`: Observe changes of this property using the {@link DEFAULT_PROPERTY_CHANGE_DETECTOR}\n     * * `string`: Use a method with this name on the custom element to check if property value has changed\n     * * `function`: Use the provided method to check if property value has changed (`this` context will be custom element instance)\n     *\n     * Default value: `true` (uses {@link DEFAULT_PROPERTY_CHANGE_DETECTOR} internally)\n     */\n    observe: boolean | keyof Type | PropertyChangeDetector;\n}\n\n/**\n * The default property change detector\n *\n * @param oldValue  The old property value\n * @param newValue  The new property value\n */\nexport const DEFAULT_PROPERTY_CHANGE_DETECTOR: PropertyChangeDetector = (oldValue: any, newValue: any) => {\n    // in case `oldValue` and `newValue` are `NaN`, `(NaN !== NaN)` returns `true`,\n    // but `(NaN === NaN || NaN === NaN)` returns `false`\n    return oldValue !== newValue && (oldValue === oldValue || newValue === newValue);\n};\n\n/**\n * The default {@link CustomElement} property declaration\n */\nexport const DEFAULT_PROPERTY_DECLARATION: PropertyDeclaration = {\n    attribute: true,\n    converter: ATTRIBUTE_CONVERTERS.default,\n    reflectAttribute: true,\n    reflectProperty: true,\n    notify: true,\n    observe: DEFAULT_PROPERTY_CHANGE_DETECTOR,\n};\n","const FIRST = /^[^]/;\nconst SPACES = /\\s+([\\S])/g;\nconst CAMELS = /[a-z]([A-Z])/g;\nconst KEBABS = /-([a-z])/g;\n\nexport function capitalize (string: string): string {\n\n    return string ? string.replace(FIRST, string[0].toUpperCase()) : string;\n}\n\nexport function uncapitalize (string: string): string {\n\n    return string ? string.replace(FIRST, string[0].toLowerCase()) : string;\n}\n\nexport function camelCase (string: string): string {\n\n    let matches;\n\n    if (string) {\n\n        string = string.trim();\n\n        while ((matches = SPACES.exec(string))) {\n\n            string = string.replace(matches[0], matches[1].toUpperCase());\n\n            SPACES.lastIndex = 0;\n        }\n\n        while ((matches = KEBABS.exec(string))) {\n\n            string = string.replace(matches[0], matches[1].toUpperCase());\n\n            KEBABS.lastIndex = 0;\n        }\n    }\n\n    return uncapitalize(string);\n}\n\nexport function kebabCase (string: string): string {\n\n    let matches;\n\n    if (string) {\n\n        string = string.trim();\n\n        while ((matches = SPACES.exec(string))) {\n\n            string = string.replace(matches[0], '-' + matches[1]);\n\n            SPACES.lastIndex = 0;\n        }\n\n        while ((matches = CAMELS.exec(string))) {\n\n            string = string.replace(matches[0], matches[0][0] + '-' + matches[1]);\n\n            CAMELS.lastIndex = 0;\n        }\n    }\n\n    return string ? string.toLowerCase() : string;\n}\n","import { html, render, TemplateResult } from 'lit-html';\nimport { ListenerDeclaration } from './decorators/listener';\nimport { PropertyDeclaration, PropertyNotifier, PropertyReflector, isPropertyReflector, isPropertyKey } from \"./decorators/property-declaration\";\nimport { kebabCase } from './utils/string-utils';\n\nconst PROPERTY_REFLECTOR_ERROR = (propertyReflector: PropertyKey | Function) => new Error(`Error executing property reflector ${ String(propertyReflector) }.`);\nconst PROPERTY_NOTIFIER_ERROR = (propertyNotifier: PropertyKey | Function) => new Error(`Error executing property notifier ${ String(propertyNotifier) }.`);\n\n/**\n * Extends the static {@link ListenerDeclaration} to include the bound listener\n */\ninterface InstanceListenerDeclaration extends ListenerDeclaration {\n\n    /**\n     * The bound listener will be stored here, so it can be removed it later\n     */\n    listener: EventListener;\n\n    /**\n     * The event target will always be resolved to an actual {@link EventTarget}\n     */\n    target: EventTarget;\n}\n\nexport class CustomElement extends HTMLElement {\n\n    static selector: string;\n\n    static shadow: boolean;\n\n    /**\n     * A map of attribute names and their respective property keys\n     *\n     * @internal\n     * @private\n     */\n    static attributes: Map<string, PropertyKey> = new Map();\n\n    /**\n     * A map of property keys and their respective property declarations\n     *\n     * @internal\n     * @private\n     */\n    static properties: Map<PropertyKey, PropertyDeclaration> = new Map();\n\n    /**\n     * A map of property keys and their respective listener declarations\n     *\n     * @internal\n     * @private\n     */\n    static listeners: Map<PropertyKey, ListenerDeclaration> = new Map();\n\n    /**\n     * Override to specify attributes which should be observed, but don't have an associated property\n     *\n     * @remark\n     * For properties which are decorated with the {@link property} decorator, an observed attribute\n     * is automatically created and does not need to be specified here. Fot attributes that don't\n     * have an associated property, return the attribute names in this getter. Changes to these\n     * attributes can be handled in the {@link attributeChangedCallback} method.\n     *\n     * When extending custom elements, make sure you return the super class's observedAttributes\n     * if you override this getter (except if you don't want to inherit observed attributes):\n     *\n     * ```typescript\n     * @customElement({\n     *      selector: 'my-element'\n     * })\n     * class MyElement extends MyBaseElement {\n     *\n     *      static get observedAttributes (): string[] {\n     *\n     *          return [...super.observedAttributes, 'my-additional-attribute'];\n     *      }\n     * }\n     * ```\n     */\n    static get observedAttributes (): string[] {\n\n        return [];\n    }\n\n    protected _renderRoot: Element | DocumentFragment;\n\n    protected _updateRequest: Promise<boolean> = Promise.resolve(true);\n\n    protected _changedProperties: Map<string, any> = new Map();\n\n    protected _notifyingProperties: Map<string, any> = new Map();\n\n    protected _listenerDeclarations: InstanceListenerDeclaration[] = [];\n\n    protected _isConnected = false;\n\n    protected _hasRequestedUpdate = false;\n\n    protected _isReflecting = false;\n\n    get isConnected (): boolean {\n\n        return this._isConnected;\n    }\n\n    constructor () {\n\n        super();\n\n        this._renderRoot = this.createRenderRoot();\n\n        console.log('constructed... ', this.constructor.name);\n    }\n\n    createRenderRoot (): Element | DocumentFragment {\n\n        return (this.constructor as typeof CustomElement).shadow ?\n            this.attachShadow({ mode: 'open' }) :\n            this;\n    }\n\n    adoptedCallback (): void {\n    }\n\n    connectedCallback (): void {\n\n        console.log('connected... ', this.constructor.name);\n\n        this._listen();\n\n        this.requestUpdate();\n    }\n\n    disconnectedCallback (): void {\n\n        console.log('disconnected... ', this.constructor.name);\n\n        this._unlisten();\n    }\n\n    /**\n     * React to attribute changes\n     *\n     * @remarks\n     * This method can be overridden to customize the handling of attribute changes. When overriding\n     * this method, a super-call should be included, to ensure attribute changes for decorated properties\n     * are processed correctly.\n     *\n     * ```typescript\n     * @customElement({\n     *      selector: 'my-element'\n     * })\n     * class MyElement extends CustomElement {\n     *\n     *      attributeChangedCallback (attribute: string, oldValue: any, newValue: any) {\n     *\n     *          super.attributeChangedCallback(attribute, oldValue, newValue);\n     *\n     *          // do custom handling...\n     *      }\n     * }\n     * ```\n     *\n     * @param attribute The name of the changed attribute\n     * @param oldValue  The old value of the attribute\n     * @param newValue  The new value of the attribute\n     */\n    attributeChangedCallback (attribute: string, oldValue: any, newValue: any): void {\n\n        if (oldValue !== newValue) this._reflectAttribute(attribute, oldValue, newValue);\n    }\n\n    propertyChangedCallback (property: string, oldValue: any, newValue: any): void {\n    }\n\n    template (): TemplateResult {\n\n        return html``;\n    }\n\n    render (): void {\n\n        console.log('render()... ', this.constructor.name);\n\n        render(this.template(), this._renderRoot);\n\n        this.renderCallback();\n    }\n\n    renderCallback (): void {\n\n        console.log('rendered... ', this.constructor.name);\n    }\n\n    update (changedProperties: Map<string, any>): void {\n\n        console.log('update()... ', changedProperties);\n\n        // TODO: Check if at least one changed property requests render\n        this.render();\n\n        changedProperties.forEach((oldValue: any, propertyKey: string) => {\n\n            this.reflectProperty(propertyKey, oldValue, this[propertyKey as keyof CustomElement]);\n        });\n\n        this._notifyingProperties.forEach((oldValue, propertyKey) => {\n\n            const propertyDeclaration = this._getPropertyDeclaration(propertyKey)!;\n            const newValue = this[propertyKey as keyof CustomElement];\n\n            if (propertyDeclaration.notify) {\n\n                if (typeof propertyDeclaration.notify === 'function') {\n\n                    try {\n                        propertyDeclaration.notify.call(this, propertyKey, oldValue, newValue);\n                    } catch (error) {\n                        throw PROPERTY_NOTIFIER_ERROR(propertyDeclaration.notify.toString());\n                    }\n\n                } else if (typeof propertyDeclaration.notify === 'string') {\n\n                    try {\n                        (this[propertyDeclaration.notify as keyof this] as unknown as PropertyNotifier)(propertyKey, oldValue, newValue);\n                    } catch (error) {\n                        throw PROPERTY_NOTIFIER_ERROR(propertyDeclaration.notify);\n                    }\n\n                } else {\n\n                    this._notify(propertyKey, oldValue, newValue);\n                }\n            }\n        });\n    }\n\n    /**\n     * Reflect a property value to its associated attribute\n     *\n     * @remarks\n     * This method checks, if any custom {@link PropertyReflector} has been defined for the\n     * property and invokes the appropriate reflector. If not, it will use the default\n     * reflector {@link _reflectProperty}.\n     *\n     * It catches any error in custom {@link PropertyReflector}s and throws a more helpful one.\n     *\n     * @param propertyKey   The propert key of the property to reflect\n     * @param oldValue      The old property value\n     * @param newValue      The new property value\n     */\n    reflectProperty (propertyKey: PropertyKey, oldValue: any, newValue: any) {\n\n        const propertyDeclaration = this._getPropertyDeclaration(propertyKey);\n\n        // TODO: only reflect if property change was not initiated by observed attribute\n\n        if (propertyDeclaration && propertyDeclaration.reflectProperty) {\n\n            if (isPropertyReflector(propertyDeclaration.reflectProperty)) {\n\n                try {\n                    propertyDeclaration.reflectProperty.call(this, propertyKey, oldValue, newValue);\n\n                } catch (error) {\n                    throw PROPERTY_REFLECTOR_ERROR(propertyDeclaration.reflectProperty);\n                }\n\n            } else if (isPropertyKey(propertyDeclaration.reflectProperty)) {\n\n                try {\n                    (this[propertyDeclaration.reflectProperty] as PropertyReflector)(propertyKey, oldValue, newValue);\n\n                } catch (error) {\n                    throw PROPERTY_REFLECTOR_ERROR(propertyDeclaration.reflectProperty);\n                }\n\n            } else {\n\n                this._reflectProperty(propertyKey, oldValue, newValue);\n            }\n        }\n    }\n\n    /**\n     * Raise custom events for property changes which occurred in the executor\n     *\n     * @remarks\n     * Property changes should trigger custom events when they are caused by internal state changes,\n     * but not if they are caused by a consumer of the custom element API directly, e.g.:\n     *\n     * ```typescript\n     * document.querySelector('my-custom-element').customProperty = true;\n     * ```.\n     *\n     * This means, we cannot automate this process through property setters, as we can't be sure who\n     * invoked the setter - internal calls or external calls.\n     *\n     * One option is to manually raise the event, which can become tedious and forces us to use string-\n     * based event names or property names, which are difficult to refactor, e.g.:\n     *\n     * ```typescript\n     * this.customProperty = true;\n     * // if we refactor the property name, we can easily miss the notify call\n     * this.notify('customProperty');\n     * ```\n     *\n     * A more convenient way is to execute the internal changes in a wrapper which can detect the changed\n     * properties and will automatically raise the required events. This eliminates the need to manually\n     * raise events and refactoring does no longer affect the process.\n     *\n     * ```typescript\n     * this.notifyChanges(() => {\n     *\n     *      this.customProperty = true;\n     *      // we can add more property modifications to notify in here\n     * });\n     * ```\n     *\n     * @param executor A function that performs the changes which should be notified\n     */\n    notifyChanges (executor: () => void) {\n\n        // back up current changed properties\n        const previousChanges = new Map(this._changedProperties);\n\n        // execute the changes\n        executor();\n\n        // add all new or updated changed properties to the notifying properties\n        for (const [propertyKey, oldValue] of this._changedProperties) {\n\n            if (!previousChanges.has(propertyKey) || previousChanges.get(propertyKey) !== oldValue) {\n\n                this._notifyingProperties.set(propertyKey, oldValue);\n            }\n        }\n    }\n\n    /**\n     * Dispatch a property-changed event.\n     *\n     * @param propertyKey\n     * @param oldValue\n     * @param newValue\n     */\n    protected _notify (propertyKey: string, oldValue: any, newValue: any): void {\n\n        const eventName = `${ kebabCase(propertyKey) }-changed`;\n\n        this.dispatchEvent(new CustomEvent(eventName, {\n            composed: true,\n            detail: {\n                property: propertyKey,\n                previous: oldValue,\n                current: newValue\n            }\n        }));\n\n        console.log(`notify ${ eventName }...`);\n    }\n\n    /**\n     * The default property reflector\n     *\n     * @remarks\n     * If no {@link PropertyReflector} is defined in the {@link PropertyDeclaration} this\n     * method is used to reflect the property value to its associated attribute.\n     *\n     * @param propertyKey   The propert key of the property to reflect\n     * @param oldValue      The old property value\n     * @param newValue      The new property value\n     *\n     * @internal\n     * @private\n     */\n    protected _reflectProperty (propertyKey: PropertyKey, oldValue: any, newValue: any) {\n\n        // this function is only called for properties which have a declaration\n        const propertyDeclaration = this._getPropertyDeclaration(propertyKey)!;\n\n        // the attribute name stored in the declaration is always a string (set by the property decorator)\n        // TODO: update types for stored property declarations?\n        const attributeName = propertyDeclaration.attribute as string;\n        // resolve the attribute value\n        const attributeValue = propertyDeclaration.converter.toAttribute(newValue);\n\n        // undefined means don't change\n        if (attributeValue === undefined) {\n\n            return;\n        }\n        // null means remove the attribute\n        else if (attributeValue === null) {\n\n            this.removeAttribute(attributeName);\n\n        } else {\n\n            this.setAttribute(attributeName, attributeValue);\n        }\n    }\n\n    protected _reflectAttribute (attributeName: string, olldValue: string, newValue: string) {\n\n        // TODO: handle custom _reflectAttribute function\n\n        const constructor = this.constructor as typeof CustomElement;\n\n        if (!constructor.attributes.has(attributeName)) {\n\n            console.log(`observed attribute \"${ attributeName }\" not found... ignoring...`);\n\n            return;\n        }\n\n        const propertyKey = constructor.attributes.get(attributeName)!;\n\n        const propertyDeclaration = this._getPropertyDeclaration(propertyKey)!;\n\n        const propertyValue = propertyDeclaration.converter!.fromAttribute!(newValue);\n\n        // TODO: this is wrong, as it prevents custom element update\n        this._isReflecting = true;\n\n        this[propertyKey as keyof this] = propertyValue;\n\n        this._isReflecting = false;\n    }\n\n    /**\n     * Bind custom element listeners.\n     *\n     * @internal\n     * @private\n     */\n    protected _listen () {\n\n        (this.constructor as typeof CustomElement).listeners.forEach((declaration, listener) => {\n\n            const instanceDeclaration: InstanceListenerDeclaration = {\n\n                // copy the class's static listener declaration into an instance listener declaration\n                event: declaration.event,\n                options: declaration.options,\n\n                // bind the components listener method to the component instance and store it in the instance declaration\n                listener: (this[listener as keyof this] as unknown as EventListener).bind(this),\n\n                // determine the event target and store it in the instance declaration\n                target: (declaration.target) ?\n                    (typeof declaration.target === 'function') ?\n                        declaration.target() :\n                        declaration.target :\n                    this\n            };\n\n            // add the bound event listener to the target\n            instanceDeclaration.target.addEventListener(instanceDeclaration.event as string, instanceDeclaration.listener, instanceDeclaration.options);\n\n            // save the instance listener declaration on the component instance\n            this._listenerDeclarations.push(instanceDeclaration);\n        });\n    }\n\n    /**\n     * Unbind custom element listeners.\n     *\n     * @internal\n     * @private\n     */\n    protected _unlisten () {\n\n        this._listenerDeclarations.forEach((declaration) => {\n\n            declaration.target.removeEventListener(declaration.event as string, declaration.listener, declaration.options);\n        });\n    }\n\n    requestUpdate (propertyKey?: string, oldValue?: any, newValue?: any): Promise<boolean> {\n\n        console.log('requestUpdate()... ', this.constructor.name);\n\n        if (this._isReflecting) {\n\n            console.log(`requestUpdate()... reflecting`);\n\n            return this._updateRequest;\n        }\n\n        if (propertyKey) {\n\n            const propertyDeclaration = this._getPropertyDeclaration(propertyKey);\n\n            if (propertyDeclaration) {\n\n                const { observe } = propertyDeclaration;\n\n                // check if property is observed\n                if (!observe) return this._updateRequest;\n                console.log(`requestUpdate()... ${ propertyKey } observe: ${ !!observe }`);\n\n                // check if property has changed\n                if (typeof observe === 'function' && !observe(oldValue, newValue)) return this._updateRequest;\n                console.log(`requestUpdate()... ${ propertyKey } changed`);\n\n                // store changed property for batch processing\n                this._changedProperties.set(propertyKey, oldValue);\n            }\n        }\n\n        if (!this._hasRequestedUpdate) {\n\n            // enqueue update request if none was enqueued already\n            this._enqueueUpdate();\n        }\n\n        return this._updateRequest;\n    }\n\n    protected _performUpdate (): Promise<void> {\n\n        console.log('performUpdate()... ', this.constructor.name);\n\n        return new Promise(resolve => {\n\n            requestAnimationFrame(() => {\n\n                this.update(this._changedProperties);\n\n                this._changedProperties = new Map();\n\n                this._notifyingProperties = new Map();\n\n                // TODO: Should this be moved before the update call?\n                // During the update, other property changes might occur...\n                this._hasRequestedUpdate = false;\n\n                resolve();\n            });\n        });\n    }\n\n    private async _enqueueUpdate () {\n\n        console.log('enqueueUpdate()... ', this.constructor.name);\n\n        let resolve: (result: boolean) => void;\n\n        const previousRequest = this._updateRequest;\n\n        this._hasRequestedUpdate = true;\n\n        this._updateRequest = new Promise<boolean>(res => resolve = res);\n\n        await previousRequest;\n\n        const result = this._performUpdate();\n\n        await result;\n\n        resolve!(!this._hasRequestedUpdate);\n    }\n\n    private _getPropertyDeclaration (propertyKey: PropertyKey): PropertyDeclaration | undefined {\n\n        return (this.constructor as typeof CustomElement).properties.get(propertyKey);\n    }\n}\n","import { CustomElement } from '../custom-element';\nimport { DecoratedCustomElementType } from './property';\n\n/**\n * A {@link CustomElement} declaration\n */\nexport interface CustomElementDeclaration {\n    /**\n     * The selector of the custom element\n     *\n     * @remarks\n     * The selector will be used to register the custom element constructor with the browser's\n     * {@link window.customElements} API. If no selector is specified, the custom element class\n     * needs to provide one in its static {@link CustomElement.selector} property.\n     * A selector defined in the {@link CustomElementDeclaration} will take precedence over the\n     * static class property.\n     */\n    selector: string;\n\n    /**\n     * Use Shadow DOM to render the custom elements template?\n     *\n     * @remarks\n     * Shadow Dom can be disabled by setting this option to `false`, in which case the custom\n     * element's template will be rendered as child nodes of the custom element. This can be\n     * useful if an isolated DOM and scoped CSS is not desired.\n     *\n     * Default value: `true`\n     */\n    shadow: boolean;\n\n    /**\n     * Automatically register the custom element with the browser's {@link window.customElements} API?\n     *\n     * @remarks\n     * In cases where you want to employ a module system which registers custom elements on\n     * a conditional basis, you can disable automatic registration by setting this option to\n     * `false`. Your module or bootstrap system will have to take care of defining the custom\n     * element later.\n     *\n     * Default value: `true`\n     */\n    define: boolean;\n}\n\nexport const DEFAULT_CUSTOM_ELEMENT_DECLARATION: CustomElementDeclaration = {\n    selector: '',\n    shadow: true,\n    define: true\n};\n\n/**\n * Decorates a {@link CustomElement} class\n *\n * @param options A custom element declaration\n */\nexport const customElement = (options: Partial<CustomElementDeclaration> = {}) => {\n\n    const declaration = { ...DEFAULT_CUSTOM_ELEMENT_DECLARATION, ...options };\n\n    return (target: typeof CustomElement) => {\n\n        const constructor = target as DecoratedCustomElementType;\n\n        constructor.selector = declaration.selector || target.selector;\n        constructor.shadow = declaration.shadow;\n\n        /**\n         * Property decorators get called before class decorators, so at this point all decorated properties\n         * have stored their associated attributes in {@link CustomElement.attributes}.\n         * We can now combine them with the user-defined {@link CustomElement.observedAttributes} and,\n         * by using a Set, eliminate all duplicates in the process.\n         *\n         * As the user-defined {@link CustomElement.observedAttributes} will also include decorator generated\n         * observed attributes, we always inherit all observed attributes from a base class. For that reason\n         * we have to keep track of attribute overrides when extending any {@link CustomElement} base class.\n         * This is done in the {@link property} decorator. Here we have to make sure to remove overridden\n         * attributes.\n         */\n        const observedAttributes = [\n            ...new Set(\n                // we take the inherited observed attributes...\n                constructor.observedAttributes\n                    // ...remove overridden generated attributes...\n                    .reduce((attributes, attribute) => attributes.concat(constructor.overridden.has(attribute) ? [] : attribute), [] as string[])\n                    // ...and recombine the list with the newly generated attributes (the Set prevents duplicates)\n                    .concat([...target.attributes.keys()])\n            )\n        ];\n\n        // TODO: delete the overridden Set from the constructor\n\n        /**\n         * Finally we override the {@link CustomElement.observedAttributes} getter with a new one, which returns\n         * the unique set of user defined and decorator generated observed attributes.\n         *\n         * N.B.: When extending an existing custom element, and oerriding a property with a different associated\n         * attribute name, the base class's original attribute name remains in the {@link CustomElement.observedAttributes}\n         * array. Changing the old attribute on the extended class will try to reflect the attribute, but won't\n         * find the attribute in the extended class's {@link CustomElement.attributes} Map and will therefore be\n         * ignored.\n         */\n        Reflect.defineProperty(constructor, 'observedAttributes', {\n            configurable: true,\n            enumerable: false,\n            get (): string[] {\n                return observedAttributes;\n            }\n        });\n\n        if (declaration.define) {\n\n            window.customElements.define(constructor.selector, constructor);\n        }\n    };\n};\n","import { CustomElement } from '../custom-element';\n\n/**\n * A {@link CustomElement} event listener declaration\n */\nexport interface ListenerDeclaration {\n\n    /**\n     * The event to listen to\n     *\n     * @remarks\n     * Setting event to `null` allows to unbind an inherited event listener.\n     */\n    event: string | null;\n\n    /**\n     * An options object that specifies characteristics about the event listener\n     */\n    options?: AddEventListenerOptions;\n\n    /**\n     * An alternative event target (by default this will be the {@link CustomElement} instance)\n     *\n     * @remarks\n     * This can be useful if you want to listen to e.g.:\n     * * window.onresize\n     * * document.onload\n     * * document.onscroll\n     * * Worker.onmessage - TODO: This could be interesting to solve, we might need to get the worker from the\n     *   component instance, maybe a use case for di @self()\n     */\n    target?: EventTarget | (() => EventTarget);\n}\n\n/**\n * Decorates a {@link CustomElement} method as an event listener\n *\n * @param options The listener declaration\n */\nexport function listener (options: ListenerDeclaration) {\n\n    return function (target: Object, propertyKey: string, descriptor: PropertyDescriptor) {\n\n        const constructor = target.constructor as typeof CustomElement;\n\n        prepareConstructor(constructor);\n\n        if (options.event === null) {\n\n            constructor.listeners.delete(propertyKey);\n\n        } else {\n\n            constructor.listeners.set(propertyKey, { ...options });\n        }\n    }\n}\n\n/**\n * Prepares the custom element constructor by initializing static properties for the listener decorator,\n * so we don't modify a base class's static properties.\n *\n * @remarks\n * When the listener decorator stores listener declarations in the constructor, we have to make sure the\n * static listeners field is initialized on the current constructor. Otherwise we add listener declarations\n * to the base class's static field. We also make sure to initialize the listener maps with the values of\n * the base class's map to properly inherit all listener declarations.\n *\n * @param constructor The custom element constructor to prepare\n *\n * @internal\n * @private\n */\nfunction prepareConstructor (constructor: typeof CustomElement) {\n\n    if (!constructor.hasOwnProperty('listeners')) constructor.listeners = new Map(constructor.listeners);\n}\n","import { CustomElement } from '../custom-element';\nimport { kebabCase } from '../utils/string-utils';\nimport { getPropertyDescriptor } from './get-property-descriptor';\nimport { DEFAULT_PROPERTY_DECLARATION, PropertyDeclaration } from './property-declaration';\n\n/**\n * A type extension to add additional properties to a {@link CustomElement} constructor during decoration\n *\n * @internal\n * @private\n */\nexport type DecoratedCustomElementType = typeof CustomElement & { overridden: Set<string> };\n\n/**\n * Decorates a {@link CustomElement} property\n *\n * @remarks\n * Many of the {@link PropertyDeclaration} options support custom functions, which will be invoked\n * with the custom element instance as `this`-context during execution. In order to support correct\n * typing in these functions, the `@property` decorator supports generic types. Here is an example\n * of how you can use this with a custom {@link PropertReflector}:\n *\n * ```typescript\n * class MyElement extends CustomElement {\n *\n *      myHiddenProperty = true;\n *\n *      // use a generic to support proper instance typing in the property reflector\n *      @property<MyElement>({\n *          reflectProperty: (propertyKey: string, oldValue: any, newValue: any) {\n *              // the generic type allows for correct typing of this\n *              if (this.myHiddenProperty && newValue) {\n *                  this.setAttribute('my-property', '');\n *              } else {\n *                  this.removeAttribute('my-property');\n *              }\n *          }\n *      })\n *      myProperty = false;\n * }\n * ```\n *\n * @param options A property declaration\n */\nexport const property = <Type extends CustomElement = CustomElement> (options: Partial<PropertyDeclaration<Type>> = {}) => {\n\n    return (target: Object, propertyKey: PropertyKey): void => {\n\n        const descriptor = getPropertyDescriptor(target, propertyKey);\n        const hiddenKey = (typeof propertyKey === 'string') ? `_${ propertyKey }` : Symbol();\n        const get = descriptor && descriptor.get || function (this: any) { return this[hiddenKey]; };\n        const set = descriptor && descriptor.set || function (this: any, value: any) { this[hiddenKey] = value; };\n\n        Object.defineProperty(target, propertyKey, {\n            configurable: true,\n            enumerable: true,\n            get (): any {\n                return get.call(this);\n            },\n            set (value: any): void {\n                const oldValue = this[propertyKey];\n                set.call(this, value);\n                // TODO: maybe invoke propertyChangedCallback instead?\n                this.requestUpdate(propertyKey, oldValue, value);\n            }\n        });\n\n        const constructor = target.constructor as DecoratedCustomElementType;\n\n        const declaration: PropertyDeclaration<Type> = { ...DEFAULT_PROPERTY_DECLARATION, ...options };\n\n        // generate the default attribute name\n        if (declaration.attribute === true) {\n\n            declaration.attribute = (typeof propertyKey === 'string') ?\n                kebabCase(propertyKey) :\n                (typeof propertyKey === 'number') ?\n                    kebabCase(`attr-${ propertyKey }`.replace(/\\./g, '-')) :\n                    // TODO: this could create multiple identical attribute names, if symbols don't have unique description\n                    kebabCase(`attr-${ String(propertyKey) }`\n                        .replace(/Symbol\\(/, 'symbol-')\n                        .replace(/\\)$/, '')\n                        // replace invalid attribute characters\n                        .replace(/\\s+|>|<|=|\\.|\\//g, '-')\n                    );\n        }\n\n        // set the default property change detector\n        if (declaration.observe === true) {\n\n            declaration.observe = DEFAULT_PROPERTY_DECLARATION.observe;\n        }\n\n        prepareConstructor(constructor);\n\n        // check if we inherited an observed attribute for the property from the base class\n        const attribute = constructor.properties.has(propertyKey) ? constructor.properties.get(propertyKey)!.attribute : undefined;\n\n        // if attribute is truthy it's a string and it will exist in the attributes map\n        if (attribute) {\n\n            // remove the inherited attribute as it's overridden\n            constructor.attributes.delete(attribute as string);\n\n            // mark attribute as overridden for {@link customElement} decorator\n            constructor.overridden.add(attribute as string);\n        }\n\n        if (declaration.attribute) {\n\n            constructor.attributes.set(declaration.attribute, propertyKey);\n        }\n\n        // store the property declaration last, so we can still access the inherited declaration\n        // when processing the attributes\n        constructor.properties.set(propertyKey, declaration as PropertyDeclaration);\n    };\n};\n\n/**\n * Prepares the custom element constructor by initializing static properties for the property decorator,\n * so we don't modify a base class's static properties.\n *\n * @remarks\n * When the property decorator stores property declarations and attribute mappings in the constructor,\n * we have to make sure those static fields are initialized on the current constructor. Otherwise we\n * add property declarations and attribute mappings to the base class's static fields. We also make\n * sure to initialize the constructors maps with the values of the base class's maps to properly\n * inherit all property declarations and attributes.\n *\n * @param constructor The custom element constructor to prepare\n *\n * @internal\n * @private\n */\nfunction prepareConstructor (constructor: DecoratedCustomElementType) {\n\n    // this will give us a compile-time error if we refactor one of the static constructor properties\n    // and we won't miss renaming the property keys\n    const properties: keyof DecoratedCustomElementType = 'properties';\n    const attributes: keyof DecoratedCustomElementType = 'attributes';\n    const overridden: keyof DecoratedCustomElementType = 'overridden';\n\n    if (!constructor.hasOwnProperty(properties)) constructor.properties = new Map(constructor.properties);\n    if (!constructor.hasOwnProperty(attributes)) constructor.attributes = new Map(constructor.attributes);\n    if (!constructor.hasOwnProperty(overridden)) constructor.overridden = new Set();\n}\n","/**\n * Get the {@link PropertyDescriptor} of a property from its prototype\n * or a parent prototype - excluding {@link Object.prototype} itself, to\n * ensure correct prototype inheritance.\n *\n * @param target        The prototype to get the descriptor from\n * @param propertyKey   The property key for which to get the descriptor\n *\n * @internal\n * @private\n */\nexport function getPropertyDescriptor (target: Object, propertyKey: PropertyKey): PropertyDescriptor | undefined {\n\n    if (propertyKey in target) {\n\n        while (target !== Object.prototype) {\n\n            if (target.hasOwnProperty(propertyKey)) {\n\n                return Object.getOwnPropertyDescriptor(target, propertyKey);\n            }\n\n            target = Object.getPrototypeOf(target);\n        }\n    }\n\n    return undefined;\n}\n"],"names":["ATTRIBUTE_CONVERTERS","default","fromAttribute","value","JSON","parse","error","toAttribute","stringify","toString","boolean","string","number","Number","object","array","date","Date","isAttributeReflector","reflector","isPropertyReflector","isPropertyNotifier","notifier","isPropertyKey","key","DEFAULT_PROPERTY_CHANGE_DETECTOR","oldValue","newValue","DEFAULT_PROPERTY_DECLARATION","attribute","converter","reflectAttribute","reflectProperty","notify","observe","SPACES","CAMELS","kebabCase","matches","trim","exec","replace","lastIndex","toLowerCase","PROPERTY_REFLECTOR_ERROR","propertyReflector","Error","String","PROPERTY_NOTIFIER_ERROR","propertyNotifier","CustomElement","HTMLElement","[object Object]","super","this","Promise","resolve","Map","_renderRoot","createRenderRoot","console","log","constructor","name","observedAttributes","isConnected","_isConnected","shadow","attachShadow","mode","_listen","requestUpdate","_unlisten","_reflectAttribute","property","html","render","template","renderCallback","changedProperties","forEach","propertyKey","_notifyingProperties","propertyDeclaration","_getPropertyDeclaration","call","_notify","_reflectProperty","executor","previousChanges","_changedProperties","has","get","set","eventName","dispatchEvent","CustomEvent","composed","detail","previous","current","attributeName","attributeValue","undefined","removeAttribute","setAttribute","olldValue","attributes","propertyValue","_isReflecting","listeners","declaration","listener","instanceDeclaration","event","options","bind","target","addEventListener","_listenerDeclarations","push","removeEventListener","_updateRequest","_hasRequestedUpdate","_enqueueUpdate","requestAnimationFrame","update","previousRequest","res","result","_performUpdate","properties","DEFAULT_CUSTOM_ELEMENT_DECLARATION","selector","define","customElement","Set","reduce","concat","overridden","keys","Reflect","defineProperty","configurable","enumerable","window","customElements","descriptor","hasOwnProperty","prepareConstructor","delete","Object","prototype","getOwnPropertyDescriptor","getPrototypeOf","getPropertyDescriptor","hiddenKey","Symbol","add"],"mappings":"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"}