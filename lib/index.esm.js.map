{"version":3,"file":"index.esm.js","sources":["../src/decorators/attribute-converter.ts","../src/decorators/utils/string-utils.ts","../src/decorators/property-declaration.ts","../src/custom-element.ts","../src/decorators/custom-element.ts","../src/decorators/listener.ts","../src/decorators/property.ts","../src/decorators/utils/get-property-descriptor.ts"],"sourcesContent":["/**\n * A function that will map an attribute value to a property value\n */\nexport type AttributeMapper<T = any> = (value: string | null) => T | null;\n\n/**\n * A function that will map a property value to an attribute value\n */\nexport type PropertyMapper<T = any> = (value: T | null) => string | null | undefined;\n\n/**\n * An object that holds an {@link AttributeMapper} and a {@link PropertyMapper}\n *\n * @remarks\n * For the most common types, a converter exists which can be referenced in the {@link PropertyDeclaration}.\n *\n * ```typescript\n * import { CustomElement, property, AttributeConverterBoolean } from 'custom-element';\n *\n * export class MyElement extends CustomElement {\n *\n *      @property({\n *          converter: AttributeConverterBoolean\n *      })\n *      myProperty = true;\n * }\n * ```\n */\nexport interface AttributeConverter<T = any> {\n    toAttribute: PropertyMapper<T>;\n    fromAttribute: AttributeMapper<T>;\n}\n\n/**\n * The default attribute converter\n *\n * @remarks\n * This converter is used as the default converter for decorated properties unless a different one\n * is specified. The converter tries to infer the property type when converting to attributes and\n * uses `JSON.parse()` when converting strings from attributes. If `JSON.parse()` throws an error,\n * the converter will use the attribute value as a string.\n */\nexport const AttributeConverterDefault: AttributeConverter = {\n    fromAttribute: (value: string | null) => {\n        // `JSON.parse()` will throw an error for empty strings - we consider it null\n        if (value === null || value === '') {\n            return null;\n        }\n        else\n            try {\n                // `JSON.parse()` will successfully parse `boolean`, `number` and `JSON.stringify`'d values\n                return JSON.parse(value);\n            }\n            catch (error) {\n                // if it throws, it means we're probably dealing with a regular string\n                return value;\n            }\n    },\n    toAttribute: (value: any) => {\n        switch (typeof value) {\n            case 'boolean':\n                return value ? '' : null;\n            case 'object':\n                return (value == null) ? value : JSON.stringify(value);\n            case 'undefined':\n                return value;\n            case 'string':\n                return value;\n            default: // number, bigint, symbol, function\n                return value.toString();\n        }\n    }\n};\n\nexport const AttributeConverterBoolean: AttributeConverter<boolean> = {\n    fromAttribute: (value: string | null) => (value !== null),\n    toAttribute: (value: boolean | null) => value ? '' : null\n}\n\nexport const AttributeConverterString: AttributeConverter<string> = {\n    fromAttribute: (value: string | null) => (value === null) ? null : value,\n    // pass through null or undefined\n    toAttribute: (value: string | null) => value\n}\n\nexport const AttributeConverterNumber: AttributeConverter<number> = {\n    fromAttribute: (value: string | null) => (value === null) ? null : Number(value),\n    // pass through null or undefined using `value == null`\n    toAttribute: (value: number | null) => (value == null) ? value : value.toString()\n}\n\nexport const AttributeConverterObject: AttributeConverter<object> = {\n    // `JSON.parse()` will throw an error for empty strings - we consider it null\n    fromAttribute: (value: string | null) => (value === null || value === '') ? null : JSON.parse(value),\n    // pass through null or undefined using `value == null`\n    toAttribute: (value: object | null) => (value == null) ? value : JSON.stringify(value)\n}\n\nexport const AttributeConverterArray: AttributeConverter<any[]> = {\n    // `JSON.parse()` will throw an error for empty strings - we consider it null\n    fromAttribute: (value: string | null) => (value === null || value === '') ? null : JSON.parse(value),\n    // pass through null or undefined using `value == null`\n    toAttribute: (value: any[] | null) => (value == null) ? value : JSON.stringify(value)\n};\n\nexport const AttributeConverterDate: AttributeConverter<Date> = {\n    // `new Date()` will return an `Invalid Date` for empty strings - we consider it null\n    fromAttribute: (value: string | null) => (value === null || value === '') ? null : new Date(value),\n    // pass through null or undefined using `value == null`\n    toAttribute: (value: Date | null) => (value == null) ? value : value.toString()\n}\n","const FIRST = /^[^]/;\nconst SPACES = /\\s+([\\S])/g;\nconst CAMELS = /[a-z]([A-Z])/g;\nconst KEBABS = /-([a-z])/g;\n\nexport function capitalize (string: string): string {\n\n    return string ? string.replace(FIRST, string[0].toUpperCase()) : string;\n}\n\nexport function uncapitalize (string: string): string {\n\n    return string ? string.replace(FIRST, string[0].toLowerCase()) : string;\n}\n\nexport function camelCase (string: string): string {\n\n    let matches;\n\n    if (string) {\n\n        string = string.trim();\n\n        while ((matches = SPACES.exec(string))) {\n\n            string = string.replace(matches[0], matches[1].toUpperCase());\n\n            SPACES.lastIndex = 0;\n        }\n\n        while ((matches = KEBABS.exec(string))) {\n\n            string = string.replace(matches[0], matches[1].toUpperCase());\n\n            KEBABS.lastIndex = 0;\n        }\n    }\n\n    return uncapitalize(string);\n}\n\nexport function kebabCase (string: string): string {\n\n    let matches;\n\n    if (string) {\n\n        string = string.trim();\n\n        while ((matches = SPACES.exec(string))) {\n\n            string = string.replace(matches[0], '-' + matches[1]);\n\n            SPACES.lastIndex = 0;\n        }\n\n        while ((matches = CAMELS.exec(string))) {\n\n            string = string.replace(matches[0], matches[0][0] + '-' + matches[1]);\n\n            CAMELS.lastIndex = 0;\n        }\n    }\n\n    return string ? string.toLowerCase() : string;\n}\n","import { CustomElement } from '../custom-element';\nimport { AttributeConverter, AttributeConverterDefault } from './attribute-converter';\nimport { kebabCase } from './utils/string-utils';\n\n/**\n * A function that will reflect an attribute value to a property\n */\nexport type AttributeReflector<Type extends CustomElement = CustomElement> = (this: Type, attributeName: string, oldValue: string | null, newValue: string | null) => void;\n\n/**\n * A function that will reflect a property value to an attribute\n */\nexport type PropertyReflector<Type extends CustomElement = CustomElement> = (this: Type, propertyKey: PropertyKey, oldValue: any, newValue: any) => void;\n\n/**\n * A function that will dispatch a custom event for a property change\n */\nexport type PropertyNotifier<Type extends CustomElement = CustomElement> = (this: Type, propertyKey: PropertyKey, oldValue: any, newValue: any) => void;\n\n/**\n * A function that will return `true` if the `oldValue` and the `newValue` of a property are different, `false` otherwise\n */\nexport type PropertyChangeDetector = (oldValue: any, newValue: any) => boolean;\n\n/**\n * A type guard for {@link AttributeReflector}\n *\n * @param reflector A reflector to test\n */\nexport function isAttributeReflector (reflector: any): reflector is AttributeReflector {\n\n    return typeof reflector === 'function';\n}\n\n/**\n * A type guard for {@link PropertyReflector}\n *\n * @param reflector A reflector to test\n */\nexport function isPropertyReflector (reflector: any): reflector is PropertyReflector {\n\n    return typeof reflector === 'function';\n}\n\n/**\n * A type guard for {@link PropertyNotifier}\n *\n * @param notifier A notifier to test\n */\nexport function isPropertyNotifier (notifier: any): notifier is PropertyNotifier {\n\n    return typeof notifier === 'function';\n}\n\n/**\n * A type guard for {@link PropertyChangeDetector}\n *\n * @param detector A detector to test\n */\nexport function isPropertyChangeDetector (detector: any): detector is PropertyChangeDetector {\n\n    return typeof detector === 'function';\n}\n\n/**\n * A type guard for {@link PropertyKey}\n *\n * @param key A property key to test\n */\nexport function isPropertyKey (key: any): key is PropertyKey {\n\n    return typeof key === 'string' || typeof key === 'number' || typeof key === 'symbol';\n}\n\n/**\n * Encodes a string for use as html attribute removing invalid attribute characters\n *\n * @param value A string to encode for use as html attribute\n * @returns     An encoded string usable as html attribute\n */\nexport function encodeAttribute (value: string): string {\n\n    return kebabCase(value.replace(/\\W+/g, '-').replace(/\\-$/, ''));\n}\n\n/**\n * A helper function to create an attribute name from a property key\n *\n * @remarks\n * Numeric property indexes or symbols can contain invalid characters for attribute names. This method\n * sanitizes those characters and replaces sequences of invalid characters with a dash.\n * Attribute names are not allowed to start with numbers either and are prefixed with 'attr-'.\n *\n * N.B.: When using custom symbols as property keys, use unique descriptions for the symbols to avoid\n * clashing attribute names.\n *\n * ```typescript\n * const a = Symbol();\n * const b = Symbol();\n *\n * a !== b; // true\n *\n * createAttributeName(a) !== createAttributeName(b); // false --> 'attr-symbol' === 'attr-symbol'\n *\n * const c = Symbol('c');\n * const d = Symbol('d');\n *\n * c !== d; // true\n *\n * createAttributeName(c) !== createAttributeName(d); // true --> 'attr-symbol-c' === 'attr-symbol-d'\n * ```\n *\n * @param propertyKey   A property key to convert to an attribute name\n * @returns             The generated attribute name\n */\nexport function createAttributeName (propertyKey: PropertyKey): string {\n\n    if (typeof propertyKey === 'string') {\n\n        return kebabCase(propertyKey);\n\n    } else {\n\n        // TODO: this could create multiple identical attribute names, if symbols don't have unique description\n        return `attr-${ encodeAttribute(String(propertyKey)) }`;\n    }\n}\n\n/**\n * A helper function to create an event name from a property key\n *\n * @remarks\n * Event names don't have the same restrictions as attribute names when it comes to invalid\n * characters. However, for consistency's sake, we apply the same rules for event names as\n * for attribute names.\n *\n * @param propertyKey   A property key to convert to an attribute name\n * @param prefix        An optional prefix, e.g.: 'on'\n * @param suffix        An optional suffix, e.g.: 'changed'\n * @returns             The generated event name\n */\nexport function createEventName (propertyKey: PropertyKey, prefix?: string, suffix?: string): string {\n\n    let propertyString = '';\n\n    if (typeof propertyKey === 'string') {\n\n        propertyString = kebabCase(propertyKey);\n\n    } else {\n\n        // TODO: this could create multiple identical event names, if symbols don't have unique description\n        propertyString = encodeAttribute(String(propertyKey));\n    }\n\n    return `${ prefix ? `${ kebabCase(prefix) }-` : '' }${ propertyString }${ suffix ? `-${ kebabCase(suffix) }` : '' }`;\n}\n\n/**\n * A {@link CustomElement} property declaration\n */\nexport interface PropertyDeclaration<Type extends CustomElement = CustomElement> {\n    /**\n     * Does property have an associated attribute?\n     *\n     * @remarks\n     * Possible values:\n     * * `false`: No attribute will be associated with this property\n     * * `true`: The attribute name will be inferred by camel-casing the property name\n     * * `string`: Use the provided string as the associated attribute name\n     *\n     * Default value: `true`\n     */\n    attribute: boolean | string;\n\n    /**\n     * Customize the conversion of values between property and associated attribute\n     *\n     * @remarks\n     * Converters are only used when {@link reflectProperty} and/or {@link reflectAttribute} are set to true.\n     * If custom reflectors are used, they have to take care or converting the property/attribute values.\n     *\n     * Default value: {@link AttributeConverterDefault}\n     */\n    converter: AttributeConverter;\n\n    /**\n     * Should the associated attribute's value be automatically reflected to the property?\n     *\n     * @remarks\n     * Possible values:\n     * * `false`: The attribute value will not be reflected to the property automatically\n     * * `true`: Any attribute change will be reflected automatically to the property using the default attribute reflector\n     * * `PropertyKey`: A method on the custom element with that property key will be invoked to handle the attribute reflection\n     * * `Function`: The provided function will be invoked with its `this` context bound to the custom element instance\n     *\n     * Default value: `true`\n     */\n    reflectAttribute: boolean | keyof Type | AttributeReflector<Type>;\n\n    /**\n     * Should the property value be automatically reflected to the associated attribute?\n     *\n     * @remarks\n     * Possible values:\n     * * `false`: The property value will not be reflected to the associated attribute automatically\n     * * `true`: Any property change will be reflected automatically to the associated attribute using the default property reflector\n     * * `PropertyKey`: A method on the custom element with that property key will be invoked to handle the property reflection\n     * * `Function`: The provided function will be invoked with its `this` context bound to the custom element instance\n     *\n     * Default value: `true`\n     */\n    reflectProperty: boolean | keyof Type | PropertyReflector<Type>;\n\n    /**\n     * Should a property value change raise a custom event?\n     *\n     * @remarks\n     * Possible values:\n     * * `false`: Don't create a custom event for this property\n     * * `true`: Create custom events for this property automatically\n     * * `PropertyKey`: Use the method with this property key on the custom element to create custom events\n     * * `Function`: Use the the provided function to create custom events (`this` context will be the custom element instance)\n     *\n     * Default value: `true`\n     */\n    notify: boolean | keyof Type | PropertyNotifier<Type>;\n\n    /**\n     * Configure how changes of this property should be monitored\n     *\n     * @remarks\n     * By default a decorated property will be observed for changes (through a custom setter for the property).\n     * Any `set`-operation of this property will therefore request an update of the custom element and initiate\n     * a render as well as reflection and notification.\n     *\n     * Possible values:\n     * * `false`: Don't observe changes of this property (this will bypass render, reflection and notification)\n     * * `true`: Observe changes of this property using the {@link DEFAULT_PROPERTY_CHANGE_DETECTOR}\n     * * `Function`: Use the provided method to check if property value has changed\n     *\n     * Default value: `true` (uses {@link DEFAULT_PROPERTY_CHANGE_DETECTOR} internally)\n     */\n    observe: boolean | PropertyChangeDetector;\n}\n\n/**\n * The default property change detector\n *\n * @param oldValue  The old property value\n * @param newValue  The new property value\n * @returns         A boolean indicating if the property value changed\n */\nexport const DEFAULT_PROPERTY_CHANGE_DETECTOR: PropertyChangeDetector = (oldValue: any, newValue: any) => {\n    // in case `oldValue` and `newValue` are `NaN`, `(NaN !== NaN)` returns `true`,\n    // but `(NaN === NaN || NaN === NaN)` returns `false`\n    return oldValue !== newValue && (oldValue === oldValue || newValue === newValue);\n};\n\n/**\n * The default {@link CustomElement} property declaration\n */\nexport const DEFAULT_PROPERTY_DECLARATION: PropertyDeclaration = {\n    attribute: true,\n    converter: AttributeConverterDefault,\n    reflectAttribute: true,\n    reflectProperty: true,\n    notify: true,\n    observe: DEFAULT_PROPERTY_CHANGE_DETECTOR,\n};\n","import { render, TemplateResult } from 'lit-html';\nimport { ListenerDeclaration } from './decorators/listener';\nimport { AttributeReflector, createEventName, isAttributeReflector, isPropertyChangeDetector, isPropertyKey, isPropertyNotifier, isPropertyReflector, PropertyDeclaration, PropertyNotifier, PropertyReflector } from \"./decorators/property-declaration\";\n\nconst ATTRIBUTE_REFLECTOR_ERROR = (attributeReflector: PropertyKey | Function) => new Error(`Error executing attribute reflector ${ String(attributeReflector) }.`);\nconst PROPERTY_REFLECTOR_ERROR = (propertyReflector: PropertyKey | Function) => new Error(`Error executing property reflector ${ String(propertyReflector) }.`);\nconst PROPERTY_NOTIFIER_ERROR = (propertyNotifier: PropertyKey | Function) => new Error(`Error executing property notifier ${ String(propertyNotifier) }.`);\nconst CHANGE_DETECTOR_ERROR = (changeDetector: PropertyKey | Function) => new Error(`Error executing property change detector ${ String(changeDetector) }.`);\n\n/**\n * Extends the static {@link ListenerDeclaration} to include the bound listener\n * for a custom element instance.\n */\ninterface InstanceListenerDeclaration extends ListenerDeclaration {\n\n    /**\n     * The bound listener will be stored here, so it can be removed it later\n     */\n    listener: EventListener;\n\n    /**\n     * The event target will always be resolved to an actual {@link EventTarget}\n     */\n    target: EventTarget;\n}\n\n/**\n * The custom element base class\n */\nexport abstract class CustomElement extends HTMLElement {\n\n    /**\n     * The custom element's selector\n     *\n     * @remarks\n     * Will be overridden by the {@link customElement} decorator's selector option, if provided.\n     * Otherwise the decorator will use this property to define the custom element.\n     */\n    static selector: string;\n\n    /**\n     * Use Shadow DOM\n     *\n     * @remarks\n     * Will be set by the {@link customElement} decorator's shadow option (defaults to `true`).\n     */\n    static shadow: boolean;\n\n    /**\n     * A map of attribute names and their respective property keys\n     *\n     * @internal\n     * @private\n     */\n    static attributes: Map<string, PropertyKey> = new Map();\n\n    /**\n     * A map of property keys and their respective property declarations\n     *\n     * @internal\n     * @private\n     */\n    static properties: Map<PropertyKey, PropertyDeclaration> = new Map();\n\n    /**\n     * A map of property keys and their respective listener declarations\n     *\n     * @internal\n     * @private\n     */\n    static listeners: Map<PropertyKey, ListenerDeclaration> = new Map();\n\n    /**\n     * Override to specify attributes which should be observed, but don't have an associated property\n     *\n     * @remark\n     * For properties which are decorated with the {@link property} decorator, an observed attribute\n     * is automatically created and does not need to be specified here. Fot attributes that don't\n     * have an associated property, return the attribute names in this getter. Changes to these\n     * attributes can be handled in the {@link attributeChangedCallback} method.\n     *\n     * When extending custom elements, make sure to return the super class's observedAttributes\n     * if you override this getter (except if you don't want to inherit observed attributes):\n     *\n     * ```typescript\n     * @customElement({\n     *      selector: 'my-element'\n     * })\n     * class MyElement extends MyBaseElement {\n     *\n     *      static get observedAttributes (): string[] {\n     *\n     *          return [...super.observedAttributes, 'my-additional-attribute'];\n     *      }\n     * }\n     * ```\n     */\n    static get observedAttributes (): string[] {\n\n        return [];\n    }\n\n    protected _renderRoot: Element | DocumentFragment;\n\n    protected _updateRequest: Promise<boolean> = Promise.resolve(true);\n\n    protected _changedProperties: Map<PropertyKey, any> = new Map();\n\n    protected _reflectingProperties: Map<PropertyKey, any> = new Map();\n\n    protected _notifyingProperties: Map<PropertyKey, any> = new Map();\n\n    protected _listenerDeclarations: InstanceListenerDeclaration[] = [];\n\n    protected _isConnected = false;\n\n    protected _isReflecting = false;\n\n    protected _hasUpdated = false;\n\n    protected _hasRequestedUpdate = false;\n\n    /**\n     * Returns `true` if the custom element's {@link connectedCallback} was executed.\n     */\n    get isConnected (): boolean {\n\n        return this._isConnected;\n    }\n\n    constructor () {\n\n        super();\n\n        this._renderRoot = this.createRenderRoot();\n    }\n\n    /**\n     * Invoked each time the custom element is moved to a new document\n     *\n     * @remarks\n     * https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements#Using_the_lifecycle_callbacks\n     */\n    adoptedCallback () {\n\n        this._notifyLifecycle('adopted');\n    }\n\n    /**\n     * Invoked each time the custom element is appended into a document-connected element\n     *\n     * @remarks\n     * https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements#Using_the_lifecycle_callbacks\n     */\n    connectedCallback () {\n\n        this._isConnected = true;\n\n        this._listen();\n\n        this.requestUpdate();\n\n        this._notifyLifecycle('connected');\n    }\n\n    /**\n     * Invoked each time the custom element is disconnected from the document's DOM\n     *\n     * @remarks\n     * https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements#Using_the_lifecycle_callbacks\n     */\n    disconnectedCallback () {\n\n        this._isConnected = false;\n\n        this._unlisten();\n\n        this._notifyLifecycle('disconnected');\n    }\n\n    /**\n     * Invoked each time one of the custom element's attributes is added, removed, or changed\n     *\n     * @remarks\n     * Which attributes to notice change for is specified in {@link observedAttributes}.\n     * https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements#Using_the_lifecycle_callbacks\n     *\n     * For decorated properties with an associated attribute, this is handled automatically.\n     *\n     * This method can be overridden to customize the handling of attribute changes. When overriding\n     * this method, a super-call should be included, to ensure attribute changes for decorated properties\n     * are processed correctly.\n     *\n     * ```typescript\n     * @customElement({\n     *      selector: 'my-element'\n     * })\n     * class MyElement extends CustomElement {\n     *\n     *      attributeChangedCallback (attribute: string, oldValue: any, newValue: any) {\n     *\n     *          super.attributeChangedCallback(attribute, oldValue, newValue);\n     *\n     *          // do custom handling...\n     *      }\n     * }\n     * ```\n     *\n     * @param attribute The name of the changed attribute\n     * @param oldValue  The old value of the attribute\n     * @param newValue  The new value of the attribute\n     */\n    attributeChangedCallback (attribute: string, oldValue: string | null, newValue: string | null) {\n\n        if (this._isReflecting) return;\n\n        if (oldValue !== newValue) this.reflectAttribute(attribute, oldValue, newValue);\n    }\n\n    /**\n     * Invoked each time the custom element updates\n     *\n     * @remarks\n     * The updateCallback is invoked synchronously from the {@link update} method and therefore happens directly after\n     * rendering, property reflection and property change events inside a {@link requestAnimationFrame}. It is safe to\n     * use this callback to set additional attributes or styles on the rendered component that can't be achieved through\n     * template bindings or reflection.\n     *\n     * @param changedProperties A map of properties that changed in the update, containg the property key and the old value\n     * @param firstUpdate       A boolean indicating if this was the first update\n     */\n    updateCallback (changedProperties: Map<PropertyKey, any>, firstUpdate: boolean) {\n\n        this._notifyLifecycle('update', { firstUpdate });\n    }\n\n    /**\n     * Creates the custom element's render root\n     *\n     * @remarks\n     * The render root is where the {@link render} method will attach its DOM output.\n     * When using the custom element with shadow mode, it will be a shadow root,\n     * otherwise it will be the custom element itself.\n     *\n     * TODO: Can slots be used without shadow DOM?\n     */\n    protected createRenderRoot (): Element | DocumentFragment {\n\n        return (this.constructor as typeof CustomElement).shadow ?\n            this.attachShadow({ mode: 'open' }) :\n            this;\n    }\n\n    /**\n     * Returns the template of the custom element\n     *\n     * @remarks\n     * Override this method to provide a template for your custom element. The method must\n     * return a {@link lit-html#TemplateResult} which is created using lit-html's\n     * {@link lit-html#html | `html`} or {@link lit-html#svg | `svg`} template methods.\n     *\n     * Return nothing if your component does not need to render a template.\n     *\n     * ```typescript\n     * import { html } from 'lit-html';\n     *\n     * @customElement({\n     *      selector: 'my-element'\n     * })\n     * class MyElement extends CustomElement {\n     *\n     *       myProperty = 'Hello';\n     *\n     *      template () {\n     *\n     *          html`<h1>${this.myProperty} World!</h1>`;\n     *      }\n     * }\n     * ```\n     */\n    protected template (): TemplateResult | void { }\n\n    /**\n     * Renders the custom element's template to its {@link _renderRoot}\n     *\n     * @remarks\n     * Uses lit-html's {@link lit-html#render} method to render a {@link lit-html#TemplateResult}.\n     */\n    protected render () {\n\n        const template = this.template();\n\n        if (template) render(template, this._renderRoot, { eventContext: this });\n    }\n\n    /**\n     * Watch property changes occurring in the executor and raise custom events\n     *\n     * @remarks\n     * Property changes should trigger custom events when they are caused by internal state changes,\n     * but not if they are caused by a consumer of the custom element API directly, e.g.:\n     *\n     * ```typescript\n     * document.querySelector('my-custom-element').customProperty = true;\n     * ```.\n     *\n     * This means, we cannot automate this process through property setters, as we can't be sure who\n     * invoked the setter - internal calls or external calls.\n     *\n     * One option is to manually raise the event, which can become tedious and forces us to use string-\n     * based event names or property names, which are difficult to refactor, e.g.:\n     *\n     * ```typescript\n     * this.customProperty = true;\n     * // if we refactor the property name, we can easily miss the notify call\n     * this.notify('customProperty');\n     * ```\n     *\n     * A more convenient way is to execute the internal changes in a wrapper which can detect the changed\n     * properties and will automatically raise the required events. This eliminates the need to manually\n     * raise events and refactoring does no longer affect the process.\n     *\n     * ```typescript\n     * this.watch(() => {\n     *\n     *      this.customProperty = true;\n     *      // we can add more property modifications to notify in here\n     * });\n     * ```\n     *\n     * @param executor A function that performs the changes which should be notified\n     */\n    protected watch (executor: () => void) {\n\n        // back up current changed properties\n        const previousChanges = new Map(this._changedProperties);\n\n        // execute the changes\n        executor();\n\n        // add all new or updated changed properties to the notifying properties\n        for (const [propertyKey, oldValue] of this._changedProperties) {\n\n            if (!previousChanges.has(propertyKey) || this.hasChanged(propertyKey, previousChanges.get(propertyKey), oldValue)) {\n\n                this._notifyingProperties.set(propertyKey, oldValue);\n            }\n        }\n    }\n\n    /**\n     * Request an update of the custom element\n     *\n     * @remarks\n     * This method is called automatically when the value of a decorated property or its associated\n     * attribute changes. If you need the custom element to update based on a state change that is\n     * not covered by a decorated property, call this method without any arguments.\n     *\n     * @param propertyKey   The name of the changed property that requests the update\n     * @param oldValue      The old property value\n     * @param newValue      the new property value\n     * @returns             A Promise which is resolved when the update is completed\n     */\n    protected requestUpdate (propertyKey?: PropertyKey, oldValue?: any, newValue?: any): Promise<boolean> {\n\n        if (propertyKey) {\n\n            if (!this.hasChanged(propertyKey, oldValue, newValue)) return this._updateRequest;\n\n            // store changed property for batch processing\n            this._changedProperties.set(propertyKey, oldValue);\n\n            // if we are in reflecting state, an attribute is reflecting to this property and we\n            // can skip reflecting the property back to the attribute\n            // property changes need to be tracked however and {@link render} must be called after\n            // the attribute change is reflected to this property\n            if (!this._isReflecting) this._reflectingProperties.set(propertyKey, oldValue);\n        }\n\n        if (!this._hasRequestedUpdate) {\n\n            // enqueue update request if none was enqueued already\n            this._enqueueUpdate();\n        }\n\n        return this._updateRequest;\n    }\n\n    /**\n     * Updates the custom element after an update was requested with {@link requestUpdate}\n     *\n     * @remarks\n     * This method renders the template, reflects changed properties to attributes and\n     * dispatches change events for properties which are marked for notification.\n     */\n    protected update () {\n\n        this.render();\n\n        // reflect all properties marked for reflection\n        this._reflectingProperties.forEach((oldValue: any, propertyKey: PropertyKey) => {\n\n            this.reflectProperty(propertyKey, oldValue, this[propertyKey as keyof CustomElement]);\n        });\n\n        // notify all properties marked for notification\n        this._notifyingProperties.forEach((oldValue, propertyKey) => {\n\n            this.notifyProperty(propertyKey, oldValue, this[propertyKey as keyof CustomElement]);\n        });\n\n        this.updateCallback(this._changedProperties, !this._hasUpdated);\n\n        this._hasUpdated = true;\n    }\n\n    /**\n     * Check if a property changed\n     *\n     * @remarks\n     * This method resolves the {@link PropertyChangeDetector} for the property and returns its result.\n     * If none is defined (the property declaration's observe option is `false`) it returns false.\n     * It catches any error in custom {@link PropertyChangeDetector}s and throws a more helpful one.\n     *\n     * @param propertyKey   The key of the property to check\n     * @param oldValue      The old property value\n     * @param newValue      The new property value\n     * @returns             `true` if the property changed, `false` otherwise\n     */\n    protected hasChanged (propertyKey: PropertyKey, oldValue: any, newValue: any): boolean {\n\n        const propertyDeclaration = this._getPropertyDeclaration(propertyKey);\n\n        // observe is either `false` or a {@link PropertyChangeDetector}\n        if (propertyDeclaration && isPropertyChangeDetector(propertyDeclaration.observe)) {\n\n            try {\n                return propertyDeclaration.observe.call(null, oldValue, newValue);\n\n            } catch (error) {\n\n                throw CHANGE_DETECTOR_ERROR(propertyDeclaration.observe);\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Reflect an attribute value to its associated property\n     *\n     * @remarks\n     * This method checks, if any custom {@link AttributeReflector} has been defined for the\n     * associated property and invokes the appropriate reflector. If not, it will use the default\n     * reflector {@link _reflectAttribute}.\n     *\n     * It catches any error in custom {@link AttributeReflector}s and throws a more helpful one.\n     *\n     * @param attributeName The propert key of the property to reflect\n     * @param oldValue      The old property value\n     * @param newValue      The new property value\n     */\n    protected reflectAttribute (attributeName: string, oldValue: string | null, newValue: string | null) {\n\n        const constructor = this.constructor as typeof CustomElement;\n\n        const propertyKey = constructor.attributes.get(attributeName);\n\n        // ignore user-defined observed attributes\n        // TODO: test this\n        if (!propertyKey) {\n\n            console.log(`observed attribute \"${ attributeName }\" not found... ignoring...`);\n\n            return;\n        }\n\n        const propertyDeclaration = this._getPropertyDeclaration(propertyKey)!;\n\n        // don't reflect if {@link propertyDeclaration.reflectAttribute} is false\n        if (propertyDeclaration.reflectAttribute) {\n\n            this._isReflecting = true;\n\n            if (isAttributeReflector(propertyDeclaration.reflectAttribute)) {\n\n                try {\n                    propertyDeclaration.reflectAttribute.call(this, attributeName, oldValue, newValue);\n\n                } catch (error) {\n\n                    throw ATTRIBUTE_REFLECTOR_ERROR(propertyDeclaration.reflectAttribute);\n                }\n\n            } else if (isPropertyKey(propertyDeclaration.reflectAttribute)) {\n\n                try {\n                    (this[propertyDeclaration.reflectAttribute] as AttributeReflector)(attributeName, oldValue, newValue);\n\n                } catch (error) {\n\n                    throw ATTRIBUTE_REFLECTOR_ERROR(propertyDeclaration.reflectAttribute);\n                }\n\n            } else {\n\n                this._reflectAttribute(attributeName, oldValue, newValue);\n            }\n\n            this._isReflecting = false;\n        }\n    }\n\n    /**\n     * Reflect a property value to its associated attribute\n     *\n     * @remarks\n     * This method checks, if any custom {@link PropertyReflector} has been defined for the\n     * property and invokes the appropriate reflector. If not, it will use the default\n     * reflector {@link _reflectProperty}.\n     *\n     * It catches any error in custom {@link PropertyReflector}s and throws a more helpful one.\n     *\n     * @param propertyKey   The propert key of the property to reflect\n     * @param oldValue      The old property value\n     * @param newValue      The new property value\n     */\n    protected reflectProperty (propertyKey: PropertyKey, oldValue: any, newValue: any) {\n\n        const propertyDeclaration = this._getPropertyDeclaration(propertyKey);\n\n        // don't reflect if {@link propertyDeclaration.reflectProperty} is false\n        if (propertyDeclaration && propertyDeclaration.reflectProperty) {\n\n            // attributeChangedCallback is called synchronously, we can catch the state there\n            this._isReflecting = true;\n\n            if (isPropertyReflector(propertyDeclaration.reflectProperty)) {\n\n                try {\n                    propertyDeclaration.reflectProperty.call(this, propertyKey, oldValue, newValue);\n\n                } catch (error) {\n\n                    throw PROPERTY_REFLECTOR_ERROR(propertyDeclaration.reflectProperty);\n                }\n\n            } else if (isPropertyKey(propertyDeclaration.reflectProperty)) {\n\n                try {\n                    (this[propertyDeclaration.reflectProperty] as PropertyReflector)(propertyKey, oldValue, newValue);\n\n                } catch (error) {\n\n                    throw PROPERTY_REFLECTOR_ERROR(propertyDeclaration.reflectProperty);\n                }\n\n            } else {\n\n                this._reflectProperty(propertyKey, oldValue, newValue);\n            }\n\n            this._isReflecting = false;\n        }\n    }\n\n    /**\n     * Raise an event for a property change\n     *\n     * @remarks\n     * This method checks, if any custom {@link PropertyNotifier} has been defined for the\n     * property and invokes the appropriate notifier. If not, it will use the default\n     * notifier {@link _notifyProperty}.\n     *\n     * It catches any error in custom {@link PropertyReflector}s and throws a more helpful one.\n     *\n     * @param propertyKey   The propert key of the property to raise an event for\n     * @param oldValue      The old property value\n     * @param newValue      The new property value\n     */\n    protected notifyProperty (propertyKey: PropertyKey, oldValue: any, newValue: any) {\n\n        const propertyDeclaration = this._getPropertyDeclaration(propertyKey);\n\n        if (propertyDeclaration && propertyDeclaration.notify) {\n\n            if (isPropertyNotifier(propertyDeclaration.notify)) {\n\n                try {\n                    propertyDeclaration.notify.call(this, propertyKey, oldValue, newValue);\n\n                } catch (error) {\n\n                    throw PROPERTY_NOTIFIER_ERROR(propertyDeclaration.notify.toString());\n                }\n\n            } else if (isPropertyKey(propertyDeclaration.notify)) {\n\n                try {\n                    (this[propertyDeclaration.notify] as PropertyNotifier)(propertyKey, oldValue, newValue);\n\n                } catch (error) {\n\n                    throw PROPERTY_NOTIFIER_ERROR(propertyDeclaration.notify);\n                }\n\n            } else {\n\n                this._notifyProperty(propertyKey, oldValue, newValue);\n            }\n        }\n    }\n\n    /**\n     * The default attribute reflector\n     *\n     * @remarks\n     * If no {@link AttributeReflector} is defined in the {@link PropertyDeclaration} this\n     * method is used to reflect the attribute value to its associated property.\n     *\n     * @param attributeName The name of the attribute to reflect\n     * @param oldValue      The old attribute value\n     * @param newValue      The new attribute value\n     *\n     * @internal\n     * @private\n     */\n    protected _reflectAttribute (attributeName: string, oldValue: string | null, newValue: string | null) {\n\n        const constructor = this.constructor as typeof CustomElement;\n\n        const propertyKey = constructor.attributes.get(attributeName)!;\n\n        const propertyDeclaration = this._getPropertyDeclaration(propertyKey)!;\n\n        const propertyValue = propertyDeclaration.converter.fromAttribute(newValue);\n\n        this[propertyKey as keyof this] = propertyValue;\n    }\n\n    /**\n     * The default property reflector\n     *\n     * @remarks\n     * If no {@link PropertyReflector} is defined in the {@link PropertyDeclaration} this\n     * method is used to reflect the property value to its associated attribute.\n     *\n     * @param propertyKey   The property key of the property to reflect\n     * @param oldValue      The old property value\n     * @param newValue      The new property value\n     *\n     * @internal\n     * @private\n     */\n    protected _reflectProperty (propertyKey: PropertyKey, oldValue: any, newValue: any) {\n\n        // this function is only called for properties which have a declaration\n        const propertyDeclaration = this._getPropertyDeclaration(propertyKey)!;\n\n        // if the default reflector is used, we need to check if an attribute for this property exists\n        // if not, we won't reflect\n        if (!propertyDeclaration.attribute) return;\n\n        // if attribute is truthy, it's a string\n        const attributeName = propertyDeclaration.attribute as string;\n\n        // resolve the attribute value\n        const attributeValue = propertyDeclaration.converter.toAttribute(newValue);\n\n        // undefined means don't change\n        if (attributeValue === undefined) {\n\n            return;\n        }\n        // null means remove the attribute\n        else if (attributeValue === null) {\n\n            this.removeAttribute(attributeName);\n\n        } else {\n\n            this.setAttribute(attributeName, attributeValue);\n        }\n    }\n\n    /**\n     * Dispatch a property-changed event\n     *\n     * @param propertyKey\n     * @param oldValue\n     * @param newValue\n     */\n    protected _notifyProperty (propertyKey: PropertyKey, oldValue: any, newValue: any): void {\n\n        const eventName = createEventName(propertyKey, '', 'changed');\n\n        this.dispatchEvent(new CustomEvent(eventName, {\n            composed: true,\n            detail: {\n                property: propertyKey,\n                previous: oldValue,\n                current: newValue\n            }\n        }));\n    }\n\n    /**\n     * Dispatch a lifecycle event\n     *\n     * @param lifecycle The lifecycle for which to raise the event\n     * @param detail    Optional event details\n     */\n    protected _notifyLifecycle (lifecycle: string, detail?: object) {\n\n        const eventName = createEventName(lifecycle, 'on');\n\n        const eventInit = {\n            composed: true,\n            ...(detail ? { detail: detail } : {})\n        };\n\n        this.dispatchEvent(new CustomEvent(eventName, eventInit));\n    }\n\n    /**\n     * Bind custom element listeners.\n     *\n     * @internal\n     * @private\n     */\n    protected _listen () {\n\n        (this.constructor as typeof CustomElement).listeners.forEach((declaration, listener) => {\n\n            const instanceDeclaration: InstanceListenerDeclaration = {\n\n                // copy the class's static listener declaration into an instance listener declaration\n                event: declaration.event,\n                options: declaration.options,\n\n                // bind the components listener method to the component instance and store it in the instance declaration\n                listener: (this[listener as keyof this] as unknown as EventListener).bind(this),\n\n                // determine the event target and store it in the instance declaration\n                target: (declaration.target) ?\n                    (typeof declaration.target === 'function') ?\n                        declaration.target() :\n                        declaration.target :\n                    this\n            };\n\n            // add the bound event listener to the target\n            instanceDeclaration.target.addEventListener(instanceDeclaration.event as string, instanceDeclaration.listener, instanceDeclaration.options);\n\n            // save the instance listener declaration on the component instance\n            this._listenerDeclarations.push(instanceDeclaration);\n        });\n    }\n\n    /**\n     * Unbind custom element listeners.\n     *\n     * @internal\n     * @private\n     */\n    protected _unlisten () {\n\n        this._listenerDeclarations.forEach((declaration) => {\n\n            declaration.target.removeEventListener(declaration.event as string, declaration.listener, declaration.options);\n        });\n    }\n\n    /**\n     * Schedule the update of the custom element\n     *\n     * @remarks\n     * Schedules the update of the custom element just before the next frame\n     * and cleans up the custom elements state afterwards.\n     */\n    protected _scheduleUpdate (): Promise<void> {\n\n        return new Promise(resolve => {\n\n            // schedule the update via requestAnimationFrame to avoid multiple redraws per frame\n            requestAnimationFrame(() => {\n\n                this.update();\n\n                this._changedProperties = new Map();\n\n                this._reflectingProperties = new Map();\n\n                this._notifyingProperties = new Map();\n\n                // mark custom element as updated after the update to prevent infinte loops in the update process\n                // N.B.: any property changes during the update will be ignored\n                this._hasRequestedUpdate = false;\n\n                resolve();\n            });\n        });\n    }\n\n    /**\n     * Enqueue a request for an asynchronous update\n     */\n    private async _enqueueUpdate () {\n\n        let resolve: (result: boolean) => void;\n\n        const previousRequest = this._updateRequest;\n\n        // mark the custom element as having requested an update, the {@link _requestUpdate} method\n        // will not enqueue a further request for update if one is scheduled\n        this._hasRequestedUpdate = true;\n\n        this._updateRequest = new Promise<boolean>(res => resolve = res);\n\n        // wait for the previous update to resolve\n        // `await` is asynchronous and will return execution to the {@link requestUpdate} method\n        // and essentially allows us to batch multiple synchronous property changes, before the\n        // execution can resume here\n        await previousRequest;\n\n        const result = this._scheduleUpdate();\n\n        // the actual update is scheduled asynchronously as well\n        await result;\n\n        // resolve the new {@link _updateRequest} after the result of the current update resolves\n        resolve!(!this._hasRequestedUpdate);\n    }\n\n    /**\n     * Gets the {@link PropertyDeclaration} for a decorated property\n     *\n     * @param propertyKey The property key for which to retrieve the declaration\n     *\n     * @internal\n     * @private\n     */\n    private _getPropertyDeclaration (propertyKey: PropertyKey): PropertyDeclaration | undefined {\n\n        return (this.constructor as typeof CustomElement).properties.get(propertyKey);\n    }\n}\n","import { CustomElement } from '../custom-element';\nimport { DecoratedCustomElementType } from './property';\n\n/**\n * A {@link CustomElement} declaration\n */\nexport interface CustomElementDeclaration {\n    /**\n     * The selector of the custom element\n     *\n     * @remarks\n     * The selector will be used to register the custom element constructor with the browser's\n     * {@link window.customElements} API. If no selector is specified, the custom element class\n     * needs to provide one in its static {@link CustomElement.selector} property.\n     * A selector defined in the {@link CustomElementDeclaration} will take precedence over the\n     * static class property.\n     */\n    selector: string;\n\n    /**\n     * Use Shadow DOM to render the custom elements template?\n     *\n     * @remarks\n     * Shadow DOM can be disabled by setting this option to `false`, in which case the custom\n     * element's template will be rendered as child nodes of the custom element. This can be\n     * useful if an isolated DOM and scoped CSS is not desired.\n     *\n     * Default value: `true`\n     */\n    shadow: boolean;\n\n    /**\n     * Automatically register the custom element with the browser's {@link window.customElements} API?\n     *\n     * @remarks\n     * In cases where you want to employ a module system which registers custom elements on\n     * a conditional basis, you can disable automatic registration by setting this option to\n     * `false`. Your module or bootstrap system will have to take care of defining the custom\n     * element later.\n     *\n     * Default value: `true`\n     */\n    define: boolean;\n}\n\nexport const DEFAULT_CUSTOM_ELEMENT_DECLARATION: CustomElementDeclaration = {\n    selector: '',\n    shadow: true,\n    define: true\n};\n\n/**\n * Decorates a {@link CustomElement} class\n *\n * @param options A custom element declaration\n */\nexport const customElement = (options: Partial<CustomElementDeclaration> = {}) => {\n\n    const declaration = { ...DEFAULT_CUSTOM_ELEMENT_DECLARATION, ...options };\n\n    return (target: typeof CustomElement) => {\n\n        const constructor = target as DecoratedCustomElementType;\n\n        constructor.selector = declaration.selector || target.selector;\n        constructor.shadow = declaration.shadow;\n\n        /**\n         * Property decorators get called before class decorators, so at this point all decorated properties\n         * have stored their associated attributes in {@link CustomElement.attributes}.\n         * We can now combine them with the user-defined {@link CustomElement.observedAttributes} and,\n         * by using a Set, eliminate all duplicates in the process.\n         *\n         * As the user-defined {@link CustomElement.observedAttributes} will also include decorator generated\n         * observed attributes, we always inherit all observed attributes from a base class. For that reason\n         * we have to keep track of attribute overrides when extending any {@link CustomElement} base class.\n         * This is done in the {@link property} decorator. Here we have to make sure to remove overridden\n         * attributes.\n         */\n        const observedAttributes = [\n            ...new Set(\n                // we take the inherited observed attributes...\n                constructor.observedAttributes\n                    // ...remove overridden generated attributes...\n                    .reduce((attributes, attribute) => attributes.concat(\n                        constructor.overridden && constructor.overridden.has(attribute) ? [] : attribute),\n                        [] as string[]\n                    )\n                    // ...and recombine the list with the newly generated attributes (the Set prevents duplicates)\n                    .concat([...target.attributes.keys()])\n            )\n        ];\n\n        // delete the overridden Set from the constructor\n        delete constructor.overridden;\n\n        /**\n         * Finally we override the {@link CustomElement.observedAttributes} getter with a new one, which returns\n         * the unique set of user defined and decorator generated observed attributes.\n         */\n        Reflect.defineProperty(constructor, 'observedAttributes', {\n            configurable: true,\n            enumerable: false,\n            get (): string[] {\n                return observedAttributes;\n            }\n        });\n\n        if (declaration.define) {\n\n            window.customElements.define(constructor.selector, constructor);\n        }\n    };\n};\n","import { CustomElement } from '../custom-element';\n\n/**\n * A {@link CustomElement} event listener declaration\n */\nexport interface ListenerDeclaration {\n\n    /**\n     * The event to listen to\n     *\n     * @remarks\n     * Setting event to `null` allows to unbind an inherited event listener.\n     */\n    event: string | null;\n\n    /**\n     * An options object that specifies characteristics about the event listener\n     */\n    options?: AddEventListenerOptions;\n\n    /**\n     * An alternative event target (by default this will be the {@link CustomElement} instance)\n     *\n     * @remarks\n     * This can be useful if you want to listen to e.g.:\n     * * window.onresize\n     * * document.onload\n     * * document.onscroll\n     * * Worker.onmessage - TODO: This could be interesting to solve, we might need to get the worker from the\n     *   component instance, maybe a use case for di @self()\n     */\n    target?: EventTarget | (() => EventTarget);\n}\n\n/**\n * Decorates a {@link CustomElement} method as an event listener\n *\n * @param options The listener declaration\n */\nexport function listener (options: ListenerDeclaration) {\n\n    return function (target: Object, propertyKey: string, descriptor: PropertyDescriptor) {\n\n        const constructor = target.constructor as typeof CustomElement;\n\n        prepareConstructor(constructor);\n\n        if (options.event === null) {\n\n            constructor.listeners.delete(propertyKey);\n\n        } else {\n\n            constructor.listeners.set(propertyKey, { ...options });\n        }\n    }\n}\n\n/**\n * Prepares the custom element constructor by initializing static properties for the listener decorator,\n * so we don't modify a base class's static properties.\n *\n * @remarks\n * When the listener decorator stores listener declarations in the constructor, we have to make sure the\n * static listeners field is initialized on the current constructor. Otherwise we add listener declarations\n * to the base class's static field. We also make sure to initialize the listener maps with the values of\n * the base class's map to properly inherit all listener declarations.\n *\n * @param constructor The custom element constructor to prepare\n *\n * @internal\n * @private\n */\nfunction prepareConstructor (constructor: typeof CustomElement) {\n\n    if (!constructor.hasOwnProperty('listeners')) constructor.listeners = new Map(constructor.listeners);\n}\n","import { CustomElement } from '../custom-element';\nimport { createAttributeName, DEFAULT_PROPERTY_DECLARATION, PropertyDeclaration } from './property-declaration';\nimport { getPropertyDescriptor } from './utils/get-property-descriptor';\n\n/**\n * A type extension to add additional properties to a {@link CustomElement} constructor during decoration\n *\n * @internal\n * @private\n */\nexport type DecoratedCustomElementType = typeof CustomElement & { overridden?: Set<string> };\n\n/**\n * Decorates a {@link CustomElement} property\n *\n * @remarks\n * Many of the {@link PropertyDeclaration} options support custom functions, which will be invoked\n * with the custom element instance as `this`-context during execution. In order to support correct\n * typing in these functions, the `@property` decorator supports generic types. Here is an example\n * of how you can use this with a custom {@link PropertyReflector}:\n *\n * ```typescript\n * class MyElement extends CustomElement {\n *\n *      myHiddenProperty = true;\n *\n *      // use a generic to support proper instance typing in the property reflector\n *      @property<MyElement>({\n *          reflectProperty: (propertyKey: string, oldValue: any, newValue: any) {\n *              // the generic type allows for correct typing of this\n *              if (this.myHiddenProperty && newValue) {\n *                  this.setAttribute('my-property', '');\n *              } else {\n *                  this.removeAttribute('my-property');\n *              }\n *          }\n *      })\n *      myProperty = false;\n * }\n * ```\n *\n * @param options A property declaration\n */\nexport const property = <Type extends CustomElement = CustomElement> (options: Partial<PropertyDeclaration<Type>> = {}) => {\n\n    return (target: Object, propertyKey: PropertyKey): void => {\n\n        /**\n         * When defining classes in TypeScript, class fields actually don't exist on the class's prototype, but\n         * rather, they are instantiated in the constructor and exist only on the instance. Accessor properties\n         * are an exception however and exist on the prototype. Furthermore, accessors are inherited and will\n         * be invoked when setting (or getting) a property on an instance of a child class, even if that class\n         * defines the property field on its own. Only if the child class defines new accessors will the parent\n         * class's accessors not be inherited.\n         * To keep this behavior intact, we need to ensure, that when we create accessors for properties, which\n         * are not declared as accessors, we invoke the parent class's accessor as expected.\n         * The {@link getPropertyDescriptor} function allows us to look for accessors on the prototype chain of\n         * the class we are decorating. If it finds an accessor on the current class, we don't need to worry as\n         * this accessor would anturally override any parent class's accessor.\n         */\n        const descriptor = getPropertyDescriptor(target, propertyKey);\n        const hiddenKey = (typeof propertyKey === 'string') ? `_${ propertyKey }` : Symbol();\n\n        // if we found an accessor descriptor (from either this class or a parent) we use it, otherwise we create\n        // default accessors to store the actual property value in a hidden field and retrieve it from there\n        const get = descriptor && descriptor.get || function (this: any) { return this[hiddenKey]; };\n        const set = descriptor && descriptor.set || function (this: any, value: any) { this[hiddenKey] = value; };\n\n        // we define a new accessor descriptor which will wrap the previously retrieved or created accessors\n        // and request an update of the CustomElement whenever the property is set\n        Object.defineProperty(target, propertyKey, {\n            configurable: true,\n            enumerable: true,\n            get (): any {\n                return get.call(this);\n            },\n            set (value: any): void {\n                const oldValue = this[propertyKey];\n                set.call(this, value);\n                this.requestUpdate(propertyKey, oldValue, value);\n            }\n        });\n\n        const constructor = target.constructor as DecoratedCustomElementType;\n\n        const declaration: PropertyDeclaration<Type> = { ...DEFAULT_PROPERTY_DECLARATION, ...options };\n\n        // generate the default attribute name\n        if (declaration.attribute === true) {\n\n            declaration.attribute = createAttributeName(propertyKey);\n        }\n\n        // set the default property change detector\n        if (declaration.observe === true) {\n\n            declaration.observe = DEFAULT_PROPERTY_DECLARATION.observe;\n        }\n\n        prepareConstructor(constructor);\n\n        // check if we inherited an observed attribute for the property from the base class\n        const attribute = constructor.properties.has(propertyKey) ? constructor.properties.get(propertyKey)!.attribute : undefined;\n\n        // if attribute is truthy it's a string and it will exist in the attributes map\n        if (attribute) {\n\n            // remove the inherited attribute as it's overridden\n            constructor.attributes.delete(attribute as string);\n\n            // mark attribute as overridden for {@link customElement} decorator\n            constructor.overridden!.add(attribute as string);\n        }\n\n        if (declaration.attribute) {\n\n            constructor.attributes.set(declaration.attribute, propertyKey);\n        }\n\n        // store the property declaration last, so we can still access the inherited declaration\n        // when processing the attributes\n        constructor.properties.set(propertyKey, declaration as PropertyDeclaration);\n    };\n};\n\n/**\n * Prepares the custom element constructor by initializing static properties for the property decorator,\n * so we don't modify a base class's static properties.\n *\n * @remarks\n * When the property decorator stores property declarations and attribute mappings in the constructor,\n * we have to make sure those static fields are initialized on the current constructor. Otherwise we\n * add property declarations and attribute mappings to the base class's static fields. We also make\n * sure to initialize the constructors maps with the values of the base class's maps to properly\n * inherit all property declarations and attributes.\n *\n * @param constructor The custom element constructor to prepare\n *\n * @internal\n * @private\n */\nfunction prepareConstructor (constructor: DecoratedCustomElementType) {\n\n    // this will give us a compile-time error if we refactor one of the static constructor properties\n    // and we won't miss renaming the property keys\n    const properties: keyof DecoratedCustomElementType = 'properties';\n    const attributes: keyof DecoratedCustomElementType = 'attributes';\n    const overridden: keyof DecoratedCustomElementType = 'overridden';\n\n    if (!constructor.hasOwnProperty(properties)) constructor.properties = new Map(constructor.properties);\n    if (!constructor.hasOwnProperty(attributes)) constructor.attributes = new Map(constructor.attributes);\n    if (!constructor.hasOwnProperty(overridden)) constructor.overridden = new Set();\n}\n","/**\n * Get the {@link PropertyDescriptor} of a property from its prototype\n * or a parent prototype - excluding {@link Object.prototype} itself.\n *\n * @param target        The prototype to get the descriptor from\n * @param propertyKey   The property key for which to get the descriptor\n *\n * @internal\n * @private\n */\nexport function getPropertyDescriptor (target: Object, propertyKey: PropertyKey): PropertyDescriptor | undefined {\n\n    if (propertyKey in target) {\n\n        while (target !== Object.prototype) {\n\n            if (target.hasOwnProperty(propertyKey)) {\n\n                return Object.getOwnPropertyDescriptor(target, propertyKey);\n            }\n\n            target = Object.getPrototypeOf(target);\n        }\n    }\n\n    return undefined;\n}\n"],"names":["AttributeConverterDefault","fromAttribute","value","JSON","parse","error","toAttribute","stringify","toString","AttributeConverterBoolean","AttributeConverterString","AttributeConverterNumber","Number","AttributeConverterObject","AttributeConverterArray","AttributeConverterDate","Date","SPACES","CAMELS","kebabCase","string","matches","trim","exec","replace","lastIndex","toLowerCase","isAttributeReflector","reflector","isPropertyReflector","isPropertyNotifier","notifier","isPropertyChangeDetector","detector","isPropertyKey","key","encodeAttribute","createAttributeName","propertyKey","String","createEventName","prefix","suffix","propertyString","DEFAULT_PROPERTY_CHANGE_DETECTOR","oldValue","newValue","DEFAULT_PROPERTY_DECLARATION","attribute","converter","reflectAttribute","reflectProperty","notify","observe","ATTRIBUTE_REFLECTOR_ERROR","attributeReflector","Error","PROPERTY_REFLECTOR_ERROR","propertyReflector","PROPERTY_NOTIFIER_ERROR","propertyNotifier","CHANGE_DETECTOR_ERROR","changeDetector","CustomElement","HTMLElement","[object Object]","super","this","Promise","resolve","Map","_renderRoot","createRenderRoot","observedAttributes","isConnected","_isConnected","_notifyLifecycle","_listen","requestUpdate","_unlisten","_isReflecting","changedProperties","firstUpdate","constructor","shadow","attachShadow","mode","template","render","eventContext","executor","previousChanges","_changedProperties","has","hasChanged","get","_notifyingProperties","set","_updateRequest","_reflectingProperties","_hasRequestedUpdate","_enqueueUpdate","forEach","notifyProperty","updateCallback","_hasUpdated","propertyDeclaration","_getPropertyDeclaration","call","attributeName","attributes","console","log","_reflectAttribute","_reflectProperty","_notifyProperty","propertyValue","attributeValue","undefined","removeAttribute","setAttribute","eventName","dispatchEvent","CustomEvent","composed","detail","property","previous","current","lifecycle","eventInit","listeners","declaration","listener","instanceDeclaration","event","options","bind","target","addEventListener","_listenerDeclarations","push","removeEventListener","requestAnimationFrame","update","previousRequest","res","result","_scheduleUpdate","properties","DEFAULT_CUSTOM_ELEMENT_DECLARATION","selector","define","customElement","Set","reduce","concat","overridden","keys","Reflect","defineProperty","configurable","enumerable","window","customElements","descriptor","hasOwnProperty","prepareConstructor","delete","Object","prototype","getOwnPropertyDescriptor","getPrototypeOf","getPropertyDescriptor","hiddenKey","Symbol","add"],"mappings":"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"}